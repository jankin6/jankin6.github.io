<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++从入门到放弃</title>
      <link href="/posts/programing/"/>
      <url>/posts/programing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">            <p>听着这首歌我突然有种学习的欲望！还好我自制力强，把这股欲望给压下去了。</p>          </div>    <div id="aplayer-OYedgZHH" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="21312101" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><h1 id="第1-7章-基本语法知识"><a href="#第1-7章-基本语法知识" class="headerlink" title="第1-7章-基本语法知识"></a>第1-7章-基本语法知识</h1><h3 id="1-布尔型：bool，取值为：true-false-。"><a href="#1-布尔型：bool，取值为：true-false-。" class="headerlink" title="1. 布尔型：bool，取值为：true / false 。"></a>1. 布尔型：<strong>bool</strong>，取值为：<strong>true / false</strong> 。</h3><p>编译系统处理逻辑型数据时，将false处理为0，true处理为1</p><p><strong>int a=1</strong>； bool flag=<strong>true</strong>; a=a+flag+true;  a=<code>3</code></p><h3 id="2-内联函数"><a href="#2-内联函数" class="headerlink" title="2. 内联函数"></a>2. <strong>内联函数</strong></h3><p><strong>内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数。</strong></p><p><strong>例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">int</span> <span class="keyword">int</span>)</span></span>;<span class="comment">//声明内置函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;<span class="comment">//定义内置函数</span></span><br><span class="line"> …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-函数的重载"><a href="#3-函数的重载" class="headerlink" title="3. 函数的重载"></a>3. <strong>函数的重载</strong></h3><p><strong>参数个数</strong>，<strong>参数类型</strong>或<strong>参数顺序</strong>三者中必须至少有一种不同</p><h3 id="4-函数模板"><a href="#4-函数模板" class="headerlink" title="4. 函数模板"></a>4. <strong>函数模板</strong></h3><p>用于函数体相同，参数个数相同而<strong>类型不同</strong>的情况。</p><p><strong>定义模板的格式：</strong></p><p><code>template &lt;typename/class T&gt;</code></p><p> <strong>通用函数定义</strong></p><p><strong>T</strong>为虚拟类型名，表示T是一个类型名，但暂未指定。等函数调用时，根据实参的类型来确定T的类型。T的名字可以自定义。</p><p><strong>注意：</strong>C++要求函数/类模板的声明和实现必须放在一个文件里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">4.10</span>，将例<span class="number">4.8</span>程序(求<span class="number">3</span>个数的最大值)改为通过模板函数实现。</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//模板声明，其中T为类型参数</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T  a, T  b, T  c)</span></span>&#123; <span class="comment">// T为虚拟的类型名</span></span><br><span class="line">    <span class="keyword">if</span>(b&gt;a) a=b;</span><br><span class="line">    <span class="keyword">if</span>(c&gt;a) a=c;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  i1=<span class="number">13</span>, i2=<span class="number">34</span>, i3=<span class="number">52</span>, i;</span><br><span class="line">    <span class="keyword">double</span>  d1=<span class="number">11.2</span>, d2=<span class="number">45.34</span>, d3=<span class="number">32.55</span>, d;</span><br><span class="line">    i=<span class="built_in">max</span>( i1, i2, i3);<span class="comment">//调用模板函数，此时T被int替代</span></span><br><span class="line">    d=<span class="built_in">max</span>( d1, d2, d3);<span class="comment">//同上，double替代T</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;“i_max=“&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;“d_max=“&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-有默认参数的函数"><a href="#5-有默认参数的函数" class="headerlink" title="5. 有默认参数的函数"></a>5. <strong>有默认参数的函数</strong></h3><p>C++中，对于多次调用同一函数时用同样的实参的情况，可以给形参一个默认值，这样形参就不必一定要从实参取值了。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">area</span><span class="params">(<span class="keyword">float</span> r=<span class="number">6.5</span>)</span></span>;<span class="comment">//指定r的默认值为6.5</span></span><br><span class="line"><span class="comment">//函数调用时实参值为6.5，则可以不必给出实参的值</span></span><br><span class="line">area( ); <span class="comment">//相当于area(6.5);</span></span><br></pre></td></tr></table></figure><p>如果不想使形参取此默认值，则通过实参另行给出。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">area(<span class="number">7.5</span>); <span class="comment">//形参得到的值为7.5，而不是6.5</span></span><br></pre></td></tr></table></figure><p>多个参数时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//只对形参r指定默认值12.5</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">volume</span><span class="params">(<span class="keyword">float</span> h,<span class="keyword">float</span> r=<span class="number">12.5</span>)</span></span>; </span><br><span class="line">函数调用可以采用以下形式： </span><br><span class="line">volume(<span class="number">45.6</span>); <span class="comment">//相当于volume(45.6,12.5)</span></span><br><span class="line">volume(<span class="number">34.2</span>,<span class="number">10.4</span>); <span class="comment">//h的值为34.2，r的值为10.4</span></span><br></pre></td></tr></table></figure><p>指定默认值的参数必须放在形参表列中的<code>最右端</code>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">float</span> a，<span class="keyword">int</span> b=<span class="number">0</span>，<span class="keyword">int</span> c，<span class="keyword">char</span> d=′a′)</span></span>;     <span class="comment">//不正确</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">float</span> a，<span class="keyword">int</span> c，<span class="keyword">int</span> b=<span class="number">0</span>, <span class="keyword">char</span> d=′a′)</span></span>;     <span class="comment">//正确</span></span><br><span class="line">如果调用上面的f2函数，可以采取下面的形式： </span><br><span class="line">f2(<span class="number">3.5</span> , <span class="number">5</span> , <span class="number">3</span> ,  ′x′) <span class="comment">//形参的值全部从实参得到</span></span><br><span class="line">f2(<span class="number">3.5</span> ,  <span class="number">5</span>,  <span class="number">3</span>)<span class="comment">//最后一个形参的值取默认值′a′</span></span><br><span class="line">f2(<span class="number">3.5</span> ,  <span class="number">5</span>)<span class="comment">//最后两个形参的值取默认值，b=0,d=′a′</span></span><br></pre></td></tr></table></figure><ul><li><p>如果函数的定义在函数调用<code>之前</code>，则应<code>在函数定义中给出默认值</code>。如果函数的定义在函数调用<code>之后</code>，则在函数调用之前需要有<code>函数声明</code>，此时必须<code>在函数声明中给出默认值</code>，在函数定义时可以不给出默认值。</p></li><li><p><strong>一个函数不能既作为重载函数，又作为有默认参数的函数。</strong>因为当调用函数时如果少写一个参数，系统无法判定是利用重载函数还是利用默认参数的函数，出现二义性，系统无法执行。</p></li></ul><h3 id="6-字符串类与字符串变量"><a href="#6-字符串类与字符串变量" class="headerlink" title="6. 字符串类与字符串变量"></a>6. <strong>字符串类与字符串变量</strong></h3><p>C++新的数据类型：<strong>字符串类型</strong>(string类型)</p><p>必须包含头文件：<code>#include &lt;string&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> string1；   <span class="comment">//定义string1为字符串变量</span></span><br><span class="line"><span class="built_in">string</span> string2=″China″; <span class="comment">//定义string2同时对其初始化</span></span><br></pre></td></tr></table></figure><p><strong>对字符串变量的赋值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string1=″Canada″;</span><br><span class="line">string2=string1;<span class="comment">//将”Canada”赋值给string2</span></span><br></pre></td></tr></table></figure><ul><li>在定义字符串变量时不需指定长度，长度随其中的字符串长度而改变。</li></ul><p><strong>对字符串变量中某一字符进行操作：<code>下标法</code>。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="keyword">word</span>=″Then″; <span class="comment">//定义并初始化字符串变量</span></span><br><span class="line"><span class="keyword">word</span>［<span class="number">2</span>］=′a′; <span class="comment">//修改后word的值为″Than″</span></span><br></pre></td></tr></table></figure><p><strong>字符串变量的输入输出</strong>:在输入输出语句中用字符串变量名，输入输出字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从键盘输入一个字符串给字符串变量string1</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; string1;   </span><br><span class="line"><span class="comment">//将字符串string2输出</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; string2;</span><br></pre></td></tr></table></figure><p><strong>字符串间相关操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 字符串复制用赋值号：string1=string2;</span><br><span class="line">(<span class="number">2</span>) 字符串连接用加号</span><br><span class="line"><span class="built_in">string</span> string1=″C++″;</span><br><span class="line"><span class="built_in">string</span> string2=″&amp; C″;</span><br><span class="line">string1=string1 + string2; <span class="comment">//连接后string1为″C++ &amp;C″。</span></span><br><span class="line">(<span class="number">3</span>) 字符串比较直接用关系运算符</span><br><span class="line">可以直接用 ==(等于)、&gt;(大于)、&lt;(小于)、!=(不等于)、&gt;=(大于或等于)、&lt;=(小于或等于)等关系运算符来进行字符串的比较</span><br></pre></td></tr></table></figure><p><strong>定义字符串数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name［<span class="number">5</span>］; </span><br><span class="line"><span class="built_in">string</span> name［<span class="number">5</span>］=&#123;″Zhang″,″Li″,″Fun″,″Wang″,″Tan″&#125;;</span><br></pre></td></tr></table></figure><ul><li>在字符串数组的每一个元素中存放一个字符串，而不是一个字符，这是字符串数组与字符数组的区别。</li><li>每一个字符串元素中只包含字符串本身的字符而不包括′＼0′（ ′＼0 ′是字符数组作为结束标记用的，字符串没有这个需要）。</li></ul><h3 id="7-const指针"><a href="#7-const指针" class="headerlink" title="7. const指针"></a>7. <strong>const指针</strong></h3><ul><li><strong><code>指向常量</code>的指针变量</strong></li></ul><p>定义形式： <code>const typename * varname</code></p><p><strong>它是一个指针变量</strong></p><p><strong>不允许<code>通过指针变量</code>改变它</strong><code>指向的对象的值</code>,<strong>若直接改变变量的值是可以的</strong></p><p>指针变量的值（即指向）是<code>可以改变</code>的</p><p>若要使变量的值始终不变，需将变量定义成为const变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">12</span>; <span class="keyword">const</span> <span class="keyword">int</span> b=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pa=&amp;a,   *pb=&amp;b;  </span><br><span class="line">*pa=<span class="number">15</span>; <span class="comment">//错误,不能通过指针修改a的值</span></span><br><span class="line">a=<span class="number">15</span>; <span class="comment">//正确，a为变量，可以修改其值</span></span><br><span class="line">*pb=<span class="number">20</span>;   b=<span class="number">20</span>； <span class="comment">//错误，b为const变量，皆不可修改</span></span><br></pre></td></tr></table></figure><ul><li><strong>常指针</strong></li></ul><p>定义形式：<code>typename *const varname</code></p><p><strong>类型为指针</strong></p><p><strong>指针变量的指向<code>不能改变</code></strong>。<strong>但是其指向的变量的值可改变</strong></p><p><strong><code>必须在定义时初始化</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">4</span> ,  b=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>  *<span class="keyword">const</span> p=&amp;a ;   <span class="comment">//定义常量指针，指向变量a</span></span><br><span class="line">*p=<span class="number">5</span>;<span class="comment">//正确，p指向a，变量a的值改为5</span></span><br><span class="line">p=&amp;b;<span class="comment">//错误，p为常量指针，不能改变其指向</span></span><br></pre></td></tr></table></figure><ul><li><strong>指向常量的常指针</strong></li></ul><p>定义形式：<code>const  typename *const varname</code></p><p><strong>是一个指针</strong></p><p><strong>不能改变其指向，也不能通过指针运算符改变指针所指向的变量的值。</strong><code>但可以直接改变变量的值</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">4</span> ,  b=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  *<span class="keyword">const</span> pt=&amp;a ;   <span class="comment">//定义常量指针，指向变量a</span></span><br><span class="line">*pt=<span class="number">5</span>;<span class="comment">//错误，不能通过指针运算符改变变量的值</span></span><br><span class="line">pt=&amp;b;<span class="comment">//错误，p为常量指针，不能改变其指向</span></span><br><span class="line">a=<span class="number">5</span>;<span class="comment">//正确，可以直接改变变量的值。若是定义为const a=4,则a=5也是错误的。</span></span><br></pre></td></tr></table></figure><h3 id="8-void指针类型"><a href="#8-void指针类型" class="headerlink" title="8. void指针类型"></a>8. <strong>void指针类型</strong></h3><p><strong>格式：<code>void *pt</code></strong>，不指向确定类型的指针。</p><p><strong>void</strong> 类型的指针变量可以存储任何类型的指针，但是不能判断出指向对象的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  *p=&amp;a； <span class="keyword">void</span> *vp=p;<span class="comment">//合法，但是只获得变量的地址，而没有获得长度</span></span><br></pre></td></tr></table></figure><p><strong>void</strong>指针赋值给其他类型的指针时都要进行类型转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type *vp = (type*)vp; <span class="comment">//转换类型也就是获得指向变量/对象大小</span></span><br></pre></td></tr></table></figure><p><strong>void</strong>指针不能参与指针运算,除非进行转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(type*)vp++; <span class="comment">//vp=vp+sizeof(type)</span></span><br></pre></td></tr></table></figure><p><strong>Example</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *q=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">void</span> *p=&amp;x;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;"*p="&lt;&lt;*p&lt;&lt;endl;//错误，非法使用指针p</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"*p="</span>&lt;&lt;*(<span class="keyword">char</span>*)p&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//正确，输出指针p所指向单元的内容</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"*p="</span>&lt;&lt;*(<span class="keyword">int</span>*)p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"*p="</span>&lt;&lt;*(<span class="keyword">float</span>*)p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"*p="</span>&lt;&lt;*(<span class="keyword">double</span>*)p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//q=p;//错误，非法赋值，将void指针赋值给整型指针</span></span><br><span class="line">    q=(<span class="keyword">int</span>*)p;<span class="comment">//正确，赋值时进行强制类型转换为int*型</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"*q="</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-引用"><a href="#9-引用" class="headerlink" title="9. 引用"></a>9. <strong>引用</strong></h3><p>格式： 类型  &amp;引用名= 变量名 。<code>&amp;</code>为引用声明符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> &amp;d=c;<span class="comment">//&amp;是引用的声明符</span></span><br><span class="line"><span class="keyword">int</span> *pt=&amp;a;<span class="comment">//&amp;是取地址运算符</span></span><br></pre></td></tr></table></figure><ul><li>引用的类型必须和其所绑定的变量的类型相同</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a=<span class="number">10.3</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b=a; <span class="comment">//错误，引用的类型必须和其所绑定的变量的类型相同</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明一个引用时，必须同时初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;a; <span class="comment">//错误！声明引用的同时必须对其初始化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以取引用的地址，实质上就是取引用的变量的地址</li></ul><p><a href="https://www.cnblogs.com/duwenxing/p/7421100.html" target="_blank" rel="noopener">C++：引用的简单理解</a></p><h3 id="10-结构体类型"><a href="#10-结构体类型" class="headerlink" title="10. 结构体类型"></a>10. <strong>结构体类型</strong></h3><p><strong>C++中结构体和类的区别</strong></p><ul><li><p><strong>结构体和类具有不同的默认访问属性。类中，对于未指定访问属性的成员，其访问属性为private，结构体中为public。</strong></p></li><li><p><strong>struct默认为public继承，class默认为private继承</strong></p></li></ul><p>实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;　</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;　　//定义结构体　　</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;　</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>　</span></span><br><span class="line"><span class="class">&#123;</span>　　</span><br><span class="line">    <span class="comment">//包含两个变量成员　</span></span><br><span class="line">    <span class="keyword">int</span> x;　　</span><br><span class="line">    <span class="keyword">int</span> y;　</span><br><span class="line">&#125;;　　</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span>　</span></span><br><span class="line"><span class="function"></span>&#123;　　</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt</span>;</span>　</span><br><span class="line">    pt.x=<span class="number">1</span>;　</span><br><span class="line">    pt.y=<span class="number">2</span>;　</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pt.x&lt;&lt;<span class="built_in">endl</span>&lt;&lt;pt.y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-new和delete运算符"><a href="#11-new和delete运算符" class="headerlink" title="11. new和delete运算符"></a>11. <strong>new和delete运算符</strong></h3><p><code>new</code>运算符：动态分配存储空间。</p><p>格式：new <strong>类型</strong> [初值]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">//开辟了一个存放整数的存储空间，返回其指针</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>); <span class="comment">//指定该整数的初值为100，并返回指针</span></span><br><span class="line"><span class="keyword">char</span> *pt=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]; <span class="comment">//开辟一个存放字符数组(10个元素)的空间，返回字符数组首地址。</span></span><br><span class="line"><span class="keyword">float</span> *p=<span class="keyword">new</span> <span class="keyword">float</span>(<span class="number">3.1415</span>); <span class="comment">//开辟一个存放float的控件，其初值为3.1415，并返回其地址给指针变量p。</span></span><br></pre></td></tr></table></figure><p><strong>delete</strong>运算符：撤销上面<code>new</code>开辟的存储空间</p><p>格式：delete 指针变量/delete [] 指针变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;<span class="comment">//删除p指向的存储空间</span></span><br><span class="line"><span class="keyword">delete</span> [] pt; <span class="comment">//删除pt指向的动态数组</span></span><br></pre></td></tr></table></figure><p><strong>实验五ex1中</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//定义Array类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:    <span class="comment">//指针指向new空间，len为初始化数组长度</span></span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> b[],<span class="keyword">int</span> length)&#123;  <span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        len=length;     <span class="comment">//初始化数组长度</span></span><br><span class="line">        a=<span class="keyword">new</span> <span class="keyword">int</span>[length];  <span class="comment">//动态创建一个与实参长度一样的数组</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)&#123;  <span class="comment">//给新创建的数组赋值</span></span><br><span class="line">            a[i]=b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Array()&#123;   <span class="comment">//析构函数，删除动态创建的数组</span></span><br><span class="line">        <span class="keyword">delete</span> [] a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="12-枚举类型"><a href="#12-枚举类型" class="headerlink" title="12. 枚举类型"></a>12. <strong>枚举类型</strong></h3><p>格式：enum 枚举类型名 [枚举常量表]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个枚举类型,&#123;&#125;中的为枚举元素/枚举常量</span></span><br><span class="line"><span class="keyword">enum</span> weekday&#123;sun,mon,tue,thu,fri,sat&#125;;</span><br><span class="line">weekday workday;</span><br><span class="line">workday=mon;  <span class="comment">//枚举变量的值只能是枚举常量之一</span></span><br></pre></td></tr></table></figure><p>枚举元素为常量，其值是一个整数，编译系统按照定义时的顺序将他们赋值为0,1,2……，所以枚举值可以按照整数比较规则进行判断比较。</p><p><strong>不能将一个整数直接赋给枚举变量，枚举变量只能接受枚举类型数据。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workday=tue;  <span class="comment">//正确，将枚举常量赋值给枚举变量</span></span><br><span class="line">workday=<span class="number">2</span>;<span class="comment">//错误，它们是不同的类型。</span></span><br></pre></td></tr></table></figure><h3 id="文档——指针和引用"><a href="#文档——指针和引用" class="headerlink" title="文档——指针和引用"></a><strong>文档——指针和引用</strong></h3><p><strong>指针变量</strong></p><p>指针是一种类型，此类型变量中存放的是另一个变量/对象的地址。</p><p>指针变量是一个实体，即在内存中实实在在的存在。指针变量本身具备变量的4个属性：变量名、变量值、变量地址、变量类型。它的<code>值就是另一个变量的地址</code>。它的<code>类型就是指针类型</code>。</p><p>通过基类型确定指向变量/对象所占据的内存大小，所以void类型的指针为空指针，表示此变量仅仅存放一个地址，没有指向对象所占内存的信息，所以void指针是无法通过指针运算符来取值的。</p><p><strong>引用</strong></p><p>而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。由于它不是一个专门的变量，所以不分配内存空间。</p><p> <strong>它们之间的区别(下面的指针皆为指针变量的简称)</strong>：</p><ul><li><p>指针是一个实体，而引用仅是个别名；</p></li><li><p>引用必须被初始化，指针不必；</p></li><li><p>引用只能在定义时被初始化一次，之后不可变；指针可以改变所指的对象；</p></li></ul><ul><li><p>不存在指向空值的引用，但是存在指向空值的指针，即引用不能为空，指针可以为空；</p></li><li><p>“sizeof 引用”得到的是所指向的变量（对象）的大小，而“sizeof 指针”得到的是指针本身的大小；</p></li><li><p>程序为指针变量分配内存区域，而引用不需要分配内存区域；</p></li><li><p>指针可以有多级，但是引用只能是一级，例如<code>int **p</code>是合法的，而<code>int &amp;&amp;a</code>是不合法的；<br>更多详细参阅<a href="">第1-7章-指针和引用.docx</a></p></li></ul><h1 id="第8章-类和对象的特性"><a href="#第8章-类和对象的特性" class="headerlink" title="第8章-类和对象的特性"></a>第8章-类和对象的特性</h1><h3 id="1-面向对象程序设计方法概述"><a href="#1-面向对象程序设计方法概述" class="headerlink" title="1. 面向对象程序设计方法概述"></a>1. <strong>面向对象程序设计方法概述</strong></h3><p> <strong>面向对象程序设计的4个主要特点</strong>：<strong>“抽象”、“封装”、“继承”、“多态”</strong></p><p><strong>C++中对象的构成：数据和函数</strong></p><ul><li>数据即对象的属性</li><li>函数：对数据进行操作，以便实现某些功能，即行为。在程序设计中称为：方法。</li></ul><h3 id="2-类的声明和对象的定义"><a href="#2-类的声明和对象的定义" class="headerlink" title="2. 类的声明和对象的定义"></a>2. <strong>类的声明和对象的定义</strong></h3><p><strong>声明中未指定访问限定符的成员，系统默认为私有。</strong></p><p>private和public可以出现多次。有效范围为开始到另一个访问限定符或类体结束时为止。</p><p><strong>定义对象的3种方法（类似结构体）</strong></p><p>方法1：先声明类类型，然后再定义对象，有两种形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>） <span class="class"><span class="keyword">class</span> 类名 对象名，例如 <span class="title">class</span> <span class="title">Student</span>  <span class="title">stud1</span>;</span> </span><br><span class="line">（<span class="number">2</span>） 类名 对象名 ，例如 Student  stud1，stud2;</span><br></pre></td></tr></table></figure><p>方法2：在声明类时定义对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span>  <span class="comment">//声明类</span></span><br><span class="line">……           </span><br><span class="line">&#125;stud1，stud2;</span><br></pre></td></tr></table></figure><p>方法3：不出现类名，直接定义对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &#123;</span><span class="comment">//无类名</span></span><br><span class="line">…                        </span><br><span class="line">&#125;stud1，stud2;<span class="comment">//定义了两个无类名的类对象</span></span><br></pre></td></tr></table></figure><h3 id="3-类的成员函数"><a href="#3-类的成员函数" class="headerlink" title="3. 类的成员函数"></a>3. <strong>类的成员函数</strong></h3><p>成员函数在<code>类内声明，类外定义</code>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">( )</span></span>;<span class="comment">//公用成员函数的函数原型</span></span><br><span class="line">……</span><br><span class="line">&#125;;<span class="comment">//类定义结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类外定义display类函数，必须在函数名前面加上类名，予以限定。</span></span><br><span class="line"><span class="keyword">void</span> Student∷<span class="built_in">display</span>( ) &#123;<span class="comment">//“::” 作用域限定符</span></span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义类外函数，若“∷”前面没有类名，或函数名前面无类名无“∷”，则函数为全局函数。如<code>∷display( )</code>或<code>display( )</code>。</p><p><strong>inline成员函数</strong></p><p>如果在类体中定义的成员函数中不包括循环等控制结构，C++系统会自动将它们作为内置(inline)函数来处理。所以类内定义的成员函数一般省略inline。</p><p>如果成员函数在类体外定义，系统并不把它默认为内置(inline)函数，如果想将这些成员函数指定为内置函数，需用inline作显式声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：类体外定义<span class="keyword">inline</span>函数</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">( )</span></span>; <span class="comment">//声明此成员函数为内置函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> <span class="keyword">inline</span> <span class="keyword">void</span> Student∷<span class="built_in">display</span>( ) &#123;<span class="comment">// 在类外定义display函数为内置函数</span></span><br><span class="line">…… <span class="comment">// 函数的定义与类定义必须在同一个文件内</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>如果在类体外定义inline函数，则必须将类定义和成员函数的定义都放在同一个头文件中(或者写在同一个源文件中)</strong>。</p><p>上文中有[函数/类模板的声明和实现必须放在一个文件里](#4. 函数模板)</p><h3 id="4-对象成员的引用"><a href="#4-对象成员的引用" class="headerlink" title="4. 对象成员的引用"></a>4. <strong>对象成员的引用</strong></h3><p>访问对象中的成员的3种方法：</p><ul><li>通过对象名和成员运算符     格式：对象名.成员名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stud1.num=<span class="number">1001</span>; <span class="comment">//num为公用的整型数据成员</span></span><br></pre></td></tr></table></figure><ul><li>通过指向对象的指针       格式：指针-&gt;成员名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;hour;  <span class="comment">//输出p指向的对象中的成员hour</span></span><br></pre></td></tr></table></figure><ul><li>通过对象的引用变量      格式：别名.成员名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Time t1;        <span class="comment">//定义对象t1</span></span><br><span class="line">Time &amp;t2=t1;  <span class="comment">//定义Time类引用变量t2</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t2.hour;   <span class="comment">//输出对象t1中的成员hour</span></span><br></pre></td></tr></table></figure><h3 id="5-几个名词解释"><a href="#5-几个名词解释" class="headerlink" title="5. 几个名词解释"></a>5. <strong>几个名词解释</strong></h3><p>方法：类的成员函数在面向对象程序理论中被称为“方法”(method)，“方法”是指对数据的操作。一个“方法”对应一种操作</p><p>消息：所谓“消息”，其实就是一个命令，由程序语句来实现。例如：stud.display( );就是向对象stud对象发出的一个“消息”，通知它执行其中的display“方法”。</p><p><strong>stud.display( )语句中，stud是对象，display()是方法，语句“stud.display( );”是消息。</strong></p><h1 id="第9章-怎样使用类和对象"><a href="#第9章-怎样使用类和对象" class="headerlink" title="第9章-怎样使用类和对象"></a>第9章-怎样使用类和对象</h1><h3 id="1-利用构造函数对数据成员的初始化"><a href="#1-利用构造函数对数据成员的初始化" class="headerlink" title="1. 利用构造函数对数据成员的初始化"></a>1. <strong>利用构造函数对数据成员的初始化</strong></h3><ul><li><p><strong>无参(默认)构造函数</strong>（在建立对象时不需要实参）</p><ol><li><p>如果类中未自定义构造函数，系统会<code>自动</code>生成一个<code>无参无函数体</code>的默认构造函数(数据成员值随机)。注意：一旦类中有其他自定义构造函数，此函数将不会再自动生成</p></li><li><p>自定义的无参构造函数</p></li><li><p>自定义的全部参数带默认值的构造函数</p></li></ol></li></ul><p>注：每个类<code>只能有一个</code>默认构造函数，不然系统无法确定调用的是哪一个默认构造函数。</p><p>例：假设A为已定义的类，此类有默认构造函数A()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A test; <span class="comment">//定义对象test，自动调用默认的构造函数A()</span></span><br></pre></td></tr></table></figure><p><strong>构造函数不需要用户调用，且不能通过函数调用的方式来调用。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A mya;<span class="comment">//A为已定义类,自动调用构造函数创建对象</span></span><br><span class="line">mya.A();<span class="comment">//错误，对象不能调用构造函数</span></span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">()</span></span>;<span class="comment">//新建对象的错误格式，此为函数原型</span></span><br></pre></td></tr></table></figure><p><strong>构造函数除了创建对象时自动调用，还可以怎么调用？</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A mya; </span><br><span class="line">mya=A(); <span class="comment">//新建一个匿名的临时对象，调用构造函数A()完成临时对象的初始化，并将临时对象赋值给mya对象，匿名对象在语句结束后即被析构。</span></span><br></pre></td></tr></table></figure><ul><li><strong>带参数的构造函数</strong></li></ul><p>带参数的构造函数首部的一般格式为<code>构造函数名(类型 1 形参1，类型2 形参2，…)</code></p><p>实参是在定义对象时给出的。定义对象的一般格式为 <code>类名 对象名(实参1，实参2，…);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span><span class="comment">//声明长方柱Box类</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Box(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>);  <span class="comment">//声明带参数的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">()</span></span>;     <span class="comment">//声明计算体积的函数</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在类外定义带参数的构造函数</span></span><br><span class="line">Box∷Box(<span class="keyword">int</span> h,<span class="keyword">int</span> w,<span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="built_in">height</span>=h;</span><br><span class="line">    <span class="built_in">width</span>=w;</span><br><span class="line">    length=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义计算体积的函数</span></span><br><span class="line"><span class="keyword">int</span> Box∷volume() &#123;</span><br><span class="line">    <span class="keyword">return</span>( <span class="built_in">height</span>*<span class="built_in">width</span>*length );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立对象box1，并指定box1长、宽、高的值</span></span><br><span class="line">    <span class="function">Box <span class="title">box1</span><span class="params">(<span class="number">12</span>,<span class="number">25</span>,<span class="number">30</span>)</span></span>; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;″box1：″&lt;&lt;box1.volume()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//建立对象box2，并指定box2长、宽、高的值</span></span><br><span class="line">    <span class="function">Box <span class="title">box2</span><span class="params">(<span class="number">15</span>,<span class="number">30</span>,<span class="number">21</span>)</span></span>;           </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;″box2：″&lt;&lt;box2.volume()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>用参数初始化表对数据成员初始化</strong></li></ul><p>不在函数体内对数据成员初始化，而是在函数首部实现</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类名::构造函数名([参数表])[:成员初始化表] &#123;</span><br><span class="line">[构造函数体]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如例<span class="number">9.2</span>中定义构造函数可以改用以下形式： </span><br><span class="line">Box∷Box(<span class="keyword">int</span> h,<span class="keyword">int</span> w,<span class="keyword">int</span> len):<span class="built_in">height</span>(h)，<span class="built_in">width</span>(w)，length(len)&#123;……&#125;</span><br><span class="line">用形参h/w/len的值初始化成员数据<span class="built_in">height</span> ……</span><br></pre></td></tr></table></figure><p><strong>注意：如果数据成员是<code>数组</code>，则应当在构造函数的函数体中用语句对其赋值，而<code>不能</code>在参数初始化表对其初始化。</strong></p><ul><li><strong>构造函数的重载</strong></li></ul><p>一个类中可以定义多个构造函数。这些构造函数具有相同的名字,而参数的个数或参数的类型不相同</p><p><strong>构造函数的重载使用说明：</strong></p><p><del>调用构造函数时不必给出实参的构造函数，称为默认构造函数。</del>一个类<code>只能有一个</code>默认构造函数。</p><p>在一个类中可以包含多个构造函数，但建立对象时只执行其中一个构造函数，并非每个构造函数都被执行。</p><ul><li><strong>使用默认参数的构造函数</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">//在声明构造函数时指定默认参数</span></span><br><span class="line">        Box(<span class="keyword">int</span> h=<span class="number">10</span>,<span class="keyword">int</span> w=<span class="number">10</span>,<span class="keyword">int</span> len=<span class="number">10</span>);</span><br><span class="line">    ……</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//在定义函数时可以不指定默认参数</span></span><br><span class="line">Box∷Box(<span class="keyword">int</span> h,<span class="keyword">int</span> w,<span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="built_in">height</span>=h;</span><br><span class="line">    <span class="built_in">width</span>=w;</span><br><span class="line">    length=len;</span><br><span class="line">&#125;        </span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    Box box1;              <span class="comment">//没有给实参 </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;″box1:″&lt;&lt;box1.volume( )&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Box <span class="title">box2</span><span class="params">(<span class="number">15</span>)</span></span>;       <span class="comment">//只给定一个实参</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;″box2:″&lt;&lt;box2.volume( )&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Box <span class="title">box3</span><span class="params">(<span class="number">15</span>,<span class="number">30</span>)</span></span>;  <span class="comment">//只给定2个实参</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;″box3:″&lt;&lt;box3.volume( )&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Box <span class="title">box4</span><span class="params">(<span class="number">15</span>,<span class="number">30</span>,<span class="number">20</span>)</span></span>;  <span class="comment">//给定3个实参</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;″box4:″&lt;&lt;box4.volume( )&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li><p>应在<code>声明</code>构造函数时指定默认值，而<code>不能只在</code>定义构造函数时指定默认值。</p></li><li><p>在声明构造函数时，形参名可以省略。例如    Box(int=10, int=10, int=10);</p></li><li><p><strong>由于不需要实参也可以调用构造函数，因此全部参数都指定了默认值的构造函数也属于默认构造函数。但一个类只能有一个默认构造函数。</strong></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box();</span><br><span class="line">Box(<span class="keyword">int</span>=<span class="number">10</span>, <span class="keyword">int</span>=<span class="number">10</span>, <span class="keyword">int</span>=<span class="number">10</span>);</span><br><span class="line">Box b1； <span class="comment">//错误，不能确定调用的是哪个构造函数</span></span><br></pre></td></tr></table></figure><ol start="4"><li>类中定义了全部都是默认参数的构造函数后，不能再定义重载构造函数（默认参数函数与重载函数会产生冲突） </li></ol></blockquote><h3 id="2-析构函数"><a href="#2-析构函数" class="headerlink" title="2. 析构函数"></a>2. <strong>析构函数</strong></h3><p>函数名：类名的前面加一个“～”符号</p><p>执行析构函数的几种情况:</p><ul><li><input checked="" disabled="" type="checkbox"> 函数中定义的对象(自动局部对象)，此函数结束，对象会被释放，在对象释放前自动执行析构函数。</li><li><input checked="" disabled="" type="checkbox"> static局部对象和全局对象在程序结束时，调用该对象的析构函数。</li><li><input checked="" disabled="" type="checkbox"> new运算符动态创建的对象，用delete运算符释放该对象时，先调用该对象的析构函数。</li></ul><p>注意:</p><ul><li><strong>析构函数<code>不返回任何值</code>，<code>没有函数类型</code>，也<code>没有函数参数</code>。因此它<code>不能被重载</code>。</strong></li><li><strong>一个类可以有多个构造函数，但只能有一个析构函数。</strong></li><li>如果没有定义析构函数，C++编译系统会自动生成一个析构函数，但没有任何操作。</li><li>销毁对象只删除回收此对象的成员函数、成员变量以及其他这个对象所占有的内存；而它所管理或者有依赖关系的一些资源不会自动销毁，需要在<code>析构函数</code>中销毁，否则会成为存在却不会被使用的资源。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：定义类A, 在类中定义一个指针类型的成员变量：</span><br><span class="line"><span class="keyword">char</span> * pa; </span><br><span class="line">定义A的对象 A a，使用pa去<span class="keyword">new</span>一块内存进行引用。</span><br><span class="line">a.pa = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]；</span><br></pre></td></tr></table></figure><p>释放a的内存的时候，系统只会自动收回指针对象pa所占的内存空间。而new出来的内存不是对象的成员，不会被回收。</p><h3 id="3-调用构造函数和析构函数的顺序"><a href="#3-调用构造函数和析构函数的顺序" class="headerlink" title="3. 调用构造函数和析构函数的顺序"></a>3. <strong>调用构造函数和析构函数的顺序</strong></h3><p><code>一般情况下</code>，程序中调用析构函数的次序与调用构造函数的次序相反： 最先被调用的构造函数(最先建立的对象)，其对应的析构函数最后调用，而最后被调用的构造函数，其对应的析构函数最先被调用。</p><h3 id="4-对象数组"><a href="#4-对象数组" class="headerlink" title="4. 对象数组"></a>4. <strong>对象数组</strong></h3><ol><li>若构造函数<code>只有一个参数</code>，定义数组时可以直接提供实参，实现对象的初始化。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student stu[<span class="number">2</span>]=&#123;<span class="number">60</span>,<span class="number">70</span>&#125;; <span class="comment">//实参传给2个数组元素的构造函数</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>若构造函数有<code>多个参数</code>，初始化方法为：在花括号中分别写出构造函数并指定实参。</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：如果构造函数有<span class="number">3</span>个参数，分别代表学号、年龄、成绩： </span><br><span class="line">Student Stud[<span class="number">2</span>]=&#123;<span class="comment">//定义对象数组</span></span><br><span class="line">  Student(<span class="number">1001</span>,<span class="number">18</span>,<span class="number">87</span>),  <span class="comment">//调用第1个元素的构造函数</span></span><br><span class="line">  Student(<span class="number">1002</span>,<span class="number">19</span>,<span class="number">76</span>),  <span class="comment">//调用第2个元素的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-对象指针"><a href="#5-对象指针" class="headerlink" title="5. 对象指针"></a>5. <strong>对象指针</strong></h3><p>编译系统会为对象分配存储空间存放其成员。对象存储空间的起始地址即对象的地址,可以定义一个指针变量，用来存放对象的指针，此指针变量即为对象指针。</p><p><strong>定义形式为 ：类名 * 对象指针名；</strong></p><p>例如：定义指向对象的指针变量并通过对象指针访问对象和对象成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span>    <span class="comment">//定义Time类和定义Time对象t1；</span></span><br><span class="line">……</span><br><span class="line">&#125;t1;</span><br><span class="line">Time * pt=&amp;t1;  <span class="comment">//定义pt为指向Time类对象的指针变量并初始化</span></span><br><span class="line">*pt              <span class="comment">//表示pt所指向的对象，即t1。</span></span><br><span class="line">(*pt).hour       <span class="comment">//pt所指向的对象中的hour成员，即t1.hour</span></span><br><span class="line">pt-&gt;hour         <span class="comment">//pt所指向的对象中的hour成员，即t1.hour</span></span><br><span class="line">(*pt).get_time()<span class="comment">//即t1.get_time</span></span><br><span class="line">pt-&gt;get_time()  <span class="comment">// 总结：(*pname).xx/pname-&gt;xx ，均可</span></span><br></pre></td></tr></table></figure><hr><ul><li><strong>指向对象<code>数据成员</code>的指针变量</strong></li></ul><blockquote><p><code>数据类型名 *指针变量名</code>；//与普通的指针变量一样</p></blockquote><p>​    例：Time类的数据成员hour为public，在类外通过指向对象数据成员的指针变量访问（较少使用）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1; <span class="comment">//定义指向整型数据的指针变量</span></span><br><span class="line">p1=&amp;t1.hour; <span class="comment">//p1指向t1.hour</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*p1&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出t1.hour的值</span></span><br></pre></td></tr></table></figure><hr><ul><li><strong>指向对象<code>成员函数</code>的指针</strong></li></ul><p><strong>指针变量的类型必须与成员函数的类型相匹配：</strong></p><ol><li><strong>函数参数的类型和参数个数</strong></li><li><strong>函数返回值的类型</strong></li><li><strong><code>所属的类</code></strong></li></ol><blockquote><p><strong>定义：数据类型名(<code>类名</code>∷指针变量名)(参数表列);</strong></p><p><strong>初始化：指针变量名=<code>&amp;</code>类名::成员函数名;</strong></p></blockquote><p>例：定义指针p2指向Time类中公用成员函数get_time</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (Time∷*p2)( ) = &amp;Time∷get_time;</span><br></pre></td></tr></table></figure><hr><ul><li><strong>this</strong> <strong>指针</strong></li></ul><p>在每个<code>成员函数</code>中都包含一个名为<code>this</code>的指针变量(隐式参数)。它是指向<code>本类对象的指针</code>，它的值是当前被调用的成员函数所在的对象的地址。所以，<code>*this</code> 即本对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">成员函数volume的定义如下： </span><br><span class="line"><span class="keyword">int</span> Box∷volume( ) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="built_in">height</span>*<span class="built_in">width</span>*length);      </span><br><span class="line">&#125;</span><br><span class="line">C++把它处理为：</span><br><span class="line"><span class="keyword">int</span> Box∷volume(Box *<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>(<span class="keyword">this</span>-&gt;<span class="built_in">height</span> * <span class="keyword">this</span>-&gt;<span class="built_in">width</span> *…);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：this指针是隐式使用的，是编译系统自动实现的，在需要时也可以显式地使用this指针。</p><h3 id="6-共用数据的保护"><a href="#6-共用数据的保护" class="headerlink" title="6. 共用数据的保护"></a>6. <strong>共用数据的保护</strong></h3><ul><li><p><strong>常对象</strong>：对象数据成员的值不能改变。注意，常对象<code>必须要有初值</code>。定义格式：</p><p><strong>类名 const 对象名[(实参表列)];</strong> 或 <strong>const 类名 对象名[(实参表列)];</strong></p></li></ul><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Time <span class="keyword">const</span> <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>)</span></span>;  <span class="comment">//成员数据必须要赋初值。</span></span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> <p>常对象的成员数据都是const类型（定义对象时，将对象的数据成员自动设置成了const成员）。</p></li><li><input checked="" disabled="" type="checkbox"> <p>注意：常对象中的成员函数<code>不会</code>被自动设置为常成员函数。常对象只保证其数据成员是常数据成员。</p></li><li><input checked="" disabled="" type="checkbox"> <p>常对象<code>只能调用其const函数</code>。const函数可以访问该对象的数据成员，但不允许修改常对象中数据成员的值(只读)。</p></li><li><p><strong>常数据成员</strong>：对象的数据成员为const数据，在<code>类定义阶段</code>声明。</p></li></ul><div class="note warning">            <p>注意：<code>只能</code>通过构造函数的<code>参数初始化表</code>对常数据成员进行初始化</p>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Time()&#123;&#125; ,报错</span></span><br><span class="line">    Time (<span class="keyword">int</span> a):hour(a)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> hour;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//若类定义中有默认构造函数，程序会报错，因为const数据成员必须通过参数初始化表来初始化</span></span><br></pre></td></tr></table></figure><p>常对象的数据成员都是const数据，那常对象的构造函数<strong><code>只能用参数初始化表对const数据成员进行初始化</code></strong></p><p>(这句话是对的),但是，//定义类时，不确定此类是否会定义常对象，不会特意定义参数初始化表。所以定义常对象时，不用参数初始化表也可以建立常对象。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test()&#123;&#125;</span><br><span class="line">    Test(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//定义const函数，用以访问const数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test::show</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Test::Test(<span class="keyword">int</span> sa)&#123;</span><br><span class="line">    a=sa;<span class="comment">//没用参数初始化表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Test <span class="title">t2</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    t1.show();</span><br><span class="line">    t2.show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意，常对象只能调用const函数，所以show函数不定义为const，程序会报错。</span></span><br></pre></td></tr></table></figure><div class="note default">            <p>原来<code>参数初始化列表</code>和<code>参数的构造函数</code>不是一回事😂</p>          </div><ul><li><strong>常成员函数</strong>：只能读取数据成员，不能修改。定义格式：类型名 函数名(参数表) <code>const</code>；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：<span class="function"><span class="keyword">void</span> <span class="title">get_time</span><span class="params">( )</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>const修饰符在<code>声明函数</code>和<code>定义函数</code>时都要有const关键字，在调用时不必加const。</p><p>常成员函数可以引用const数据成员可以被const和非const成员函数引用，但不能修改它。</p><p>const数据成员可以被const和非const成员函数引用，但不能修改它。</p><p><strong>注意：类中的常成员函数<code>不能</code>调用另一个非const成员函数，即只能调用const成员函数。</strong></p><p><strong>表9.1</strong></p><table><thead><tr><th>数据成员</th><th>非const的普通成员函数</th><th>const成员函数</th></tr></thead><tbody><tr><td>非const的普通数据成员</td><td>可以引用，也可以改变值</td><td>可以引用，但不可以改变值</td></tr><tr><td>const数据成员</td><td>可以引用，但不可以改变值</td><td>可以引用，但不可以改变值</td></tr><tr><td>const对象</td><td>不允许</td><td>可以引用，但不可以改变值</td></tr></tbody></table><h3 id="7-指向对象的常指针"><a href="#7-指向对象的常指针" class="headerlink" title="7. 指向对象的常指针"></a>7. <strong>指向对象的常指针</strong></h3><p>将指针变量声明为const型，这样<code>指针值始终保持为其初值</code>，不能改变。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Time t1(10,12,15), t2; //定义Time对象</span><br><span class="line"><span class="comment">//const位置在指针变量名前面，规定ptr1的值是常值</span></span><br><span class="line">Time * <span class="keyword">const</span> ptr1; </span><br><span class="line">ptr1=&amp;t1; <span class="comment">//ptr1指向对象t1，此后不能再改变指向</span></span><br><span class="line">ptr1=&amp;t2; <span class="comment">//错误，ptr1不能改变指向</span></span><br></pre></td></tr></table></figure><p>定义形式：<strong>类名 *</strong> <strong>const</strong> <strong>指针变量名；</strong></p><p>也可在定义时初始化，如将上面3，4行合并为：<code>Time * const ptr1=&amp;t1</code>; </p><p>注意：</p><ol><li>指向不能变，但可以改变所指对象的值</li><li>指向<code>变量</code>的const指针<a href="#7.const指针">必须在定义时初始化</a>(P178)，而指向<code>对象</code>的指针定义时可以不立即初始化，但是一旦赋值，后面就不能再次赋值。</li></ol><h3 id="8-指向常对象的指针变量"><a href="#8-指向常对象的指针变量" class="headerlink" title="8. 指向常对象的指针变量"></a>8. <strong>指向常对象的指针变量</strong></h3><p>定义形式：const 类型名 * 指针变量名；</p><p>表示不能<code>通过此指针变量</code>来改变此常对象值。</p><p>注意：</p><ol><li><p>常对象只能用指向常对象的指针变量指向它，而不能用一般的(指向非const型变量的)指针变量去指向它（防止通过指针改变其值）。</p></li><li><p>指向常对象的指针变量可以改变其指向的对象。</p></li><li><p>指向常对象的指针变量除了可以指向常对象外，还可以指向非const对象，但此时不能通过此指针变量改变该对象的值（此非const对象可以通过对象本身改变）</p></li><li><p>指向常对象的指针最常用于函数的形参，如果函数的形参是指向<code>非const型</code>对象的指针，实参只能用指向非const对象的指针(在函数中需要改变参数值)。如果函数的形参是指向const型对象的指针，实参可以是指向const对象的指针，或指向非const对象的指针。对应关系见教材的表9.2。</p><p><strong>对前面[指向常变量的指针变量](# 7.const指针)的进一步讨论</strong></p></li></ol><p><strong>说明</strong>：</p><ol><li><strong>如果一个变量已被声明为常变量，只能用指向常变量的指针变量指向它</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> c[]=<span class="string">"boy"</span>;<span class="comment">//定义const型的char数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1;<span class="comment">//定义p1为指向const型的char变量的指针变量</span></span><br><span class="line">p1=c;<span class="comment">//合法，p1指向常变量</span></span><br><span class="line"><span class="keyword">char</span> *p2=c;<span class="comment">//不合法，p2不是指向常变量的指针变量</span></span><br></pre></td></tr></table></figure><ol start="2"><li>指向常变量的指针变量除了可以指向常变量外，还可以指向未被声明为const的。此时不能通过此指针改变该变量的值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1=<span class="string">'a'</span>;<span class="comment">//定义字符变量，它未被声明为const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1;<span class="comment">//定义了一个指向常变量的指针变量p</span></span><br><span class="line">p1=&amp;c1;<span class="comment">//使p指向字符变量c1</span></span><br><span class="line">*p=<span class="string">'b'</span>;<span class="comment">//非法，不能通过p改变变量c1的值</span></span><br><span class="line">c1=<span class="string">'b'</span>;<span class="comment">//合法，没有通过p访问c1，c1不是常变量</span></span><br></pre></td></tr></table></figure><p><strong>表9.2</strong></p><table><thead><tr><th>形参</th><th>实参</th><th>合法否</th><th>改变指针所指向的变量的值</th></tr></thead><tbody><tr><td>指向非const型变量的指针</td><td>非const变量的地址</td><td>合法</td><td>可以</td></tr><tr><td>指向非const型变量的指针</td><td>const变量的地址</td><td>非法</td><td>/</td></tr><tr><td>指向const型变量的指针</td><td>const变量的地址</td><td>合法</td><td>不可以</td></tr><tr><td>指向const型变量的指针</td><td>非const变量的地址</td><td>合法</td><td>不可以</td></tr></tbody></table><h3 id="9-对象的常引用"><a href="#9-对象的常引用" class="headerlink" title="9. 对象的常引用"></a>9. <strong>对象的常引用</strong></h3><p>形参为对象的引用，实参为对象名，则在调用函数进行虚实结合时，并不是为形参另外开辟一个存储空间，而是把实参对象的地址传给形参(引用名)，这样引用名也指向实参对象。         </p><p>如果不希望在函数中修改实参的值，可以把引用对象声明为const(常引用)。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> Time &amp;t)</span></span>;</span><br></pre></td></tr></table></figure><p>const 引用常对象时只能访问该对象的<code>const 函数</code>。</p><h3 id="const型数据的小结"><a href="#const型数据的小结" class="headerlink" title="const型数据的小结"></a><strong>const型数据的小结</strong></h3><table><thead><tr><th>形式</th><th>含义</th></tr></thead><tbody><tr><td>Time <code>const</code> t1;<br /><code>const</code> Time t1;</td><td>t1是<code>常对象</code>，其值在任何情况下都不能改变(类似const int a=3;)。通过对象只能调用其const方法。</td></tr><tr><td><code>const</code> int hour;</td><td><code>常数据成员</code>，只能通过类的构造函数的参数初始化表对常数据成员进行初始化</td></tr><tr><td>void Time∷fun( )<code>const</code></td><td><code>常成员函数</code>，可以引用，但不能修改本类中的数据成员，可以引用const/非const数据成员。函数中只能调用const成员函数</td></tr><tr><td>Time * <code>const</code> p;</td><td><code>指向对象的常指针</code>，p的值(即p的指向)不能改变</td></tr><tr><td><code>const</code> Time *p;</td><td><code>指向常对象的指针</code>，其指向的类对象的值不能通过指针来改变。但是p可改变指向。对象属性值也可以通过类对象直接改变。</td></tr><tr><td><code>const</code> Time &amp;t1=t;</td><td><code>常引用</code>，t1是Time类对象t的引用，二者指向同一段内存空间,t值不能改变</td></tr></tbody></table><h3 id="10-对象的动态建立和释放"><a href="#10-对象的动态建立和释放" class="headerlink" title="10. 对象的动态建立和释放"></a>10. <strong>对象的动态建立和释放</strong></h3><ul><li>用new创建对象后，将返回一个<code>指向新对象的指针</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box *pt=<span class="keyword">new</span> Box(<span class="number">12</span>,<span class="number">15</span>,<span class="number">18</span>);<span class="comment">//在pt中存放了新建对象的起始地址</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pt-&gt;<span class="built_in">height</span>;           <span class="comment">//输出该对象的height成员</span></span><br></pre></td></tr></table></figure><ul><li>动态建立数组：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box *pt=<span class="keyword">new</span> Box[n];<span class="comment">//n为定义个int变量</span></span><br></pre></td></tr></table></figure><p>每个元素都会自动调用Box类的默认构造函数，若Box类没有默认构造函数，则创建对象失败。</p><p>若new对象失败，大多数C++编译系统返回一个0指针值。</p><p>不再需要由new建立的对象时，用delete运算符予以释放。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pt;<span class="comment">//释放pt指向的内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] pt;<span class="comment">//释放pt指向的数组空间</span></span><br></pre></td></tr></table></figure><h3 id="11-对象的赋值"><a href="#11-对象的赋值" class="headerlink" title="11. 对象的赋值"></a>11. <strong>对象的赋值</strong></h3><p>同类对象之间可以互相<code>赋值</code>，即一个对象的值（数据成员）赋给另一个同类的对象（被赋值对象已创建）。</p><blockquote><p>对象赋值格式：<br>    对象名1 = 对象名2; <code>//两个对象必须属于同一个类</code>。</p></blockquote><p>注意：</p><ol><li>对象的赋值只对其中的<code>数据成员</code>赋值，而不对成员函数赋值。</li><li>类的数据成员中<code>不能包括动态分配的数据</code>(new运算符建立的动态数据)，否则在赋值时可能出现严重后果。</li></ol><h3 id="12-对象的复制"><a href="#12-对象的复制" class="headerlink" title="12. 对象的复制"></a>12. <strong>对象的复制</strong></h3><p>用一个已有的对象复制出多个完全相同的对象（拷贝构造函数）。</p><blockquote><p>定义：<br>    类名(const 类名&amp; 对象名); </p></blockquote><p>​    参数：本类已有对象的引用，一般会用const修饰。</p><p>​    作用：将实参对象的<code>成员值</code>赋给新的对象中对应的成员，若没有定义复制构造函数，系统会自动创建一个。注意：同类对象之间可以访问对方的private变量。</p><div class="note info">            <p>调用格式：<br>    类名 对象2(对象1)；//用对象1复制出对象2。<br>另一种调用格式：<br>    类名 对象1 = 对象2；//对象2已存在</p>          </div><div class="note warning">            <ul><li><strong>对象的复制和对象的赋值的区别</strong>：<br>对象的赋值是对一个已经存在的对象赋值，因此必须先定义被赋值的对象，才能进行赋值。例如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box b1;</span><br><span class="line">b1=Box b2; <span class="comment">//b1已经定义，所以属于赋值</span></span><br></pre></td></tr></table></figure>对象的复制则是从无到有地建立一个新对象，并使它与一个已有的对象完全相同(包括对象的结构和成员的值)。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box b1; </span><br><span class="line">Box b3=b1; <span class="comment">//新建box3，所以属于复制</span></span><br></pre></td></tr></table></figure>          </div><div class="note warning">            <ul><li><strong>普通构造函数和复制构造函数的区别</strong>：<ul><li>形式上：复制构造函数的形参为本类引用<ul><li>类名(形参表列); //例如：<code>Box(int h,int w,int len)</code>;</li><li>类名(类名&amp; 对象名); //例如：<code>Box(const Box &amp;b)</code>;</li></ul></li><li>系统根据<code>实参的类型</code>选择调用的构造函数。</li><li>拷贝构造函数的被调情况<ol><li>新建一个对象，并用另一个同类的对象对它初始化。</li><li>构造函数的参数为同类的对象（有时会是临时对象，所以需要const修饰）。</li><li>继承时，子类的构造函数中用父类对象来对子类的子对象进行初始化（详见继承）。</li></ol></li></ul></li></ul>          </div><h3 id="13-静态数据成员"><a href="#13-静态数据成员" class="headerlink" title="13. 静态数据成员"></a>13. <strong>静态数据成员</strong></h3><p>静态数据成员：<strong><code>属于类</code></strong>，多个对象共有。关键字static。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">( )</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> <span class="built_in">height</span>;  <span class="comment">//把height定义为静态的数据成员</span></span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>静态的数据成员在内存中只占一份空间。如果改变它的值，则在各对象中这个数据成员的值都同时改变了。</p><div class="note warning">            <ol><li><p>只声明了类而未定义对象，类的一般数据成员不占内存空间。</p></li><li><p>类定义中有静态数据成员，不定义对象也为静态数据成员分配空间。</p></li><li><p>静态数据成员不随对象的建立而分配空间，也不随对象的撤销而释放。静态数据成员是在程序编译时被分配空间的，到程序结束时才释放空间。</p></li><li><p>静态数据成员可以初始化，但只能在<code>类体外</code>进行初始化。形式为：</p></li></ol><blockquote><p>数据类型  类名∷静态数据成员名=初值；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Box∷<span class="built_in">height</span>=<span class="number">10</span>; <span class="comment">//对Box类中的static数据成员初始化</span></span><br></pre></td></tr></table></figure><p>不必在初始化语句中加static。不能用参数初始化表对静态数据成员初始化。例如：Box类中的static数据成员height： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box(<span class="keyword">int</span> h,<span class="keyword">int</span> w,<span class="keyword">int</span> len):<span class="built_in">height</span>(h)&#123; &#125;<span class="comment">//错误语句，height是静态数据成员</span></span><br></pre></td></tr></table></figure><ol start="5"><li>如果未对静态数据成员赋初值，则编译系统会自动赋予初值0。</li><li>静态数据成员既可以通过对象名引用，也可以通过类名来引用。若静态数据成员被定义为私有的，必须通过public成员函数引用。</li></ol>          </div><h3 id="14-静态成员函数"><a href="#14-静态成员函数" class="headerlink" title="14. 静态成员函数"></a>14. <strong>静态成员函数</strong></h3><p>格式：函数的前面加static</p><p>静态成员函数是类的一部分（类函数），而不是对象的一部分。</p><p>调用方式：</p><ul><li>用类名和域运算符“∷”</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">volume</span><span class="params">( )</span></span>;<span class="comment">//定义静态成员函数</span></span><br><span class="line">Box∷volume( );<span class="comment">//通过类名调用静态成员函数</span></span><br></pre></td></tr></table></figure><ul><li>通过对象名调用：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.volume( ); <span class="comment">//通过对象调用静态成员函数</span></span><br></pre></td></tr></table></figure><p>*<em>静态成员函数只能直接访问本类的<code>静态成员</code>。 *</em></p><p><strong>要引用本类的非静态成员，需先建立本类对象，通过对象引用，如：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设a已定义为Box类对象</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.<span class="built_in">width</span>&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//通过本类对象a引用box类的非静态成员</span></span><br></pre></td></tr></table></figure><ul><li><strong>静态成员函数和普通成员函数的区别</strong><ul><li>静态成员函数不包含指向具体对象的this指针</li><li>普通成员函数包含一个指向具体对象的this指针。</li></ul></li></ul><h3 id="15-友元"><a href="#15-友元" class="headerlink" title="15. 友元"></a>15. <strong>友元</strong></h3><p>友元包括<code>友元函数</code>和<code>友元类</code>。</p><p>友元函数包括全局函数和类的成员函数，一个函数可以被多个类声明为“朋友”。</p><ul><li>将函数声明为友元函数，</li></ul><p>在类体中用friend对某个类外的函数(全局函数或其他类的成员函数)<code>进行声明</code>，此函数就称为本类的友元函数。友元函数可以访问这个类中的私有成员。例如：友元全局函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Time &amp;)</span></span>;  <span class="comment">//声明display函数为Time类的友元函数</span></span><br><span class="line">  <span class="keyword">private</span>:<span class="comment">//以下数据是私有数据成员</span></span><br><span class="line">     <span class="keyword">int</span> hour; ……</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Time&amp; t)</span> </span>&#123; <span class="comment">//Time类的友元函数，形参Time对象的引用</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;t.hour&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//引用t的私有数据成员时，必须加上对象名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>友元成员函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span>   <span class="comment">//Date类的提前引用声明，若没有提前引用声明，编译会出错。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span>  <span class="comment">//类中的display函数将访问Data中的private数据。</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Time(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>);<span class="comment">//声明构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Date &amp;)</span></span>; <span class="comment">//成员函数display是Date类的友元函数，形参是Date类对象的引用</span></span><br><span class="line">    ……  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span>  <span class="comment">//声明Date类，它的private数据可以被友元函数访问</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//声明Time中的display函数为友元成员函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Time∷<span class="built_in">display</span>(Date &amp;); </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> month; <span class="comment">//Time类中的display可以通过对象访问private数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::display</span><span class="params">(Date &amp;d)</span></span>&#123; <span class="comment">//注意，只能位于正式声明类Date后，因为函数需要用到Date类的成员</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;d.month.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>友元类</li></ul><p>可以将一个类(例如B类)声明为另一个类(例如A类)的友元类。友元类B中的所有函数都是A类的友元函数，可以访问A类中的所有成员。</p><p><strong>声明友元类的形式为：</strong> <strong>friend</strong> <strong>类名；</strong></p><p>例如，在A类的定义体中用以下语句声明B类为其友元类：<br>        <code>friend B</code>;</p><div class="note warning">            <p>友元使用注意：</p><ol><li>友元的关系是<code>单向</code>的而不是双向的。</li><li>友元的关系不能传递。</li><li>一般并不把整个类声明为友元类，而只将确实有需要的成员函数声明为友元函数</li></ol>          </div><h3 id="16-类模板"><a href="#16-类模板" class="headerlink" title="16. 类模板"></a>16. <strong>类模板</strong></h3><p>有两个或多个类，其功能相同，仅仅是数据类型不同，可以声明一个通用的类模板，它可以有<code>一个或多个</code>虚拟的类型参数。</p><p>定义及使用： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与函数模板类似</span></span><br><span class="line"><span class="comment">//注意，不要分号</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> 类型参数名&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> 类名&#123;</span></span><br><span class="line"><span class="comment">//定义类体，使用类型参数名来作为虚拟类型</span></span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如p290：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">numtype</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Compare</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Compare(numtype a,numtype b)&#123;</span><br><span class="line">        x=a;y=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">numtype <span class="title">max</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>(x&gt;y)?x:y;&#125;</span><br><span class="line">    <span class="function">numtype <span class="title">mmin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>(x&lt;y)?x:y;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    numtype x,y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>利用类模板可以建立含多种数据类型的类。例如：</p><p>   <code>template &lt;class numtype&gt;</code><br>​     class Compare{ //类模板名为Compare<br>​         ……<br>​     }</p><ul><li><strong>使用类模板</strong></li></ul><blockquote><p>类模板名 &lt;实际类型名&gt; 对象名(参数表);</p></blockquote><p>   Compare cmp(4,7);  // 错误，Compare是类模板名，不是一个具体的类，类模板中的类型numtype并不是一个实际的类型，只是一个虚拟的类型，无法用它去定义对象。</p><p><code>Compare &lt;int&gt; cmp(4,7);</code>  //正确，进行编译时，编译系统就用int取代类模板中的类型参数numtype</p></blockquote><p>如果在<code>类模板外</code>定义成员函数，应写成类模板形式(函数模板)： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> 虚拟类型参数&gt;</span></span><br><span class="line"><span class="class">函数类型 类模板名&lt;虚拟类型参数&gt;∷成员函数名(函数形参表列) &#123;</span>…&#125;</span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">numtype</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">numtype</span> <span class="title">Compare</span>&lt;numtype&gt;:</span>:<span class="built_in">max</span>()&#123;<span class="keyword">return</span>(x&gt;y)?x:y;&#125;</span><br></pre></td></tr></table></figure><p>类模板使用说明： </p><ol><li>模板的类型参数可以有一个或多个，且每个类型前面都必须加class，例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">someclass</span>&#123;</span>…&#125;;</span><br></pre></td></tr></table></figure><p>在定义对象时分别代入实际的类型名，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someclass&lt; <span class="keyword">int</span> , <span class="keyword">double</span> &gt; obj;</span><br></pre></td></tr></table></figure><ol start="2"><li>模板可以有层次，一个类模板可以作为基类，派生出派生模板类。</li><li>类模板的实现部分可以写在class内，也可以写在class外，但是<code>声明与实现必须在同一个文件内实现</code>。最好将类模板放在头文件内，其它文件使用时通过include包含即可(与函数模板类似)。</li></ol><h3 id="文档——const函数的重载"><a href="#文档——const函数的重载" class="headerlink" title="文档——const函数的重载"></a>文档——const函数的重载</h3><p>在使用const函数时，注意有一种重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">function</span> <span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">function</span> <span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在类中，由于隐含的this形参的存在，const的function函数使得作为形参的this指针的类型变为指向<code>const对象</code>的指针，而非const版本的使得作为形参的this指针就是正常版本的指针。此处是发生重载的本质。</p><p>重载函数在调用过程中，由于const对象只能调用其const函数，所以对于const对象调用的就选取const性质的成员函数，而普通的对象调用就选取非const性质的成员函数。</p><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul><li><p>类的成员变量不能在定义时进行初始化</p></li><li><p>一个函数不能既作为重载函数，又作为有默认参数的函数</p></li><li><p>this指针存在的目的是，保证每个对象拥有自己的数据成员，但共享处理这些数据成员的代码在一个成员函数中经常需要调用其他函数（非本类的成员函数），而有时需要把当前对象（即对象的地址）作为参数传递给被调用函数，这时必须使用this指针。</p></li><li><p>静态成员函数对类的数据成员访问，只允许是静态数据成员</p></li><li><p>模板函数可以用同名的另一个模板函数重载。</p></li><li><p>拷贝构造函数的参数是，某个对象的引用名</p></li><li><p>析构函数，无形参，也不可重载</p></li><li><p>已知类A中的一个成员函数的说明如下：void Set(A &amp;a);则该函数的参数“A &amp;a”的含义是，类A对象引用a用作函数的形参</p></li><li><p>假定AB为一个类，则执行AB x；语句时将自动调用该类的，无参构造函数</p></li><li><p>定AB为一个类，则执行 “AB a(2), b[3], *p[4];”语句时共调用该类构造函数的次数为，4</p><p>——a(2)调用1次带参数的构造函数，b[3]调用3次无参数的构造函数，指针没有给它分配空间，没有调用构造函数，所以共调用构造函数的次数为4。</p></li><li><p>类A的成员函数void get()在类外定义时的函数首部为<code>void A::get()</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假定AA是一个类，“<span class="function">AA* <span class="title">abc</span><span class="params">()</span><span class="keyword">const</span></span>;”是该类中一个成员函数的原型，若该函数返回<span class="keyword">this</span>值，当用x.abc()调用该成员函数后，x的值（ 不变</span><br><span class="line">假定AA是一个类，“<span class="function">AA&amp; <span class="title">abc</span><span class="params">()</span></span>;”是该类中一个成员函数的原型，若该函数存在对*<span class="keyword">this</span>赋值的语句，当用x.abc()调用该成员函数后，x的值()已经被改变</span><br></pre></td></tr></table></figure><h1 id="第10章-运算符重载"><a href="#第10章-运算符重载" class="headerlink" title="第10章-运算符重载"></a>第10章-运算符重载</h1><h3 id="1-运算符重载的方法"><a href="#1-运算符重载的方法" class="headerlink" title="1. 运算符重载的方法"></a>1. <strong>运算符重载的方法</strong></h3><p>重载运算符的函数格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数类型 <span class="keyword">operator</span> 运算符名称 (形参表列)&#123;</span><br><span class="line">…… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>函数</code>实现复数相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span> <span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Complex()&#123;&#125;</span><br><span class="line">Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i):real(r),imag(i)&#123;&#125;</span><br><span class="line"><span class="function">Complex <span class="title">complex_add</span><span class="params">(Complex &amp;c2)</span></span>; <span class="comment">//声明相加函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> real;  <span class="comment">//实部</span></span><br><span class="line"><span class="keyword">double</span> imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complex::display</span><span class="params">()</span></span>&#123;<span class="comment">//定义输出函数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;“(”&lt;&lt;real&lt;&lt;“,”&lt;&lt;imag&lt;&lt;“i)”&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Complex <span class="title">Complex::complex_add</span><span class="params">(Complex &amp;c2)</span> <span class="comment">//定义复数相加函数</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">Complex c;</span><br><span class="line">c.real=real+c2.real;</span><br><span class="line">c.imag=imag+c2.imag;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>运算符重载</code>实现复数相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span><span class="comment">//复数类</span></span><br><span class="line">Complex <span class="keyword">operator</span> +(Complex &amp;c2); <span class="comment">//运算符重载函数</span></span><br><span class="line">&#125;;</span><br><span class="line">Complex Complex∷<span class="keyword">operator</span> +(Complex &amp;c2) &#123;</span><br><span class="line">Complex c;<span class="comment">//定义运算后返回的复数</span></span><br><span class="line">c.real=real+c2.real;  <span class="comment">//本对象的real与c2的real相加</span></span><br><span class="line">c.imag=imag+c2.imag;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">Complex c1(3,4), c2(5,-10), c3;</span><br><span class="line">c3=c1+c2;       <span class="comment">//运算符+用于复数运算</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;″c1+c2=″;        c3.<span class="built_in">display</span>( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数实现与运算符重载都可以实现相同的功能</p><p>运算符被重载后，其原有功能仍然<code>保留</code>，编译器会根据表达式中的数据类型决定运算符的使用。</p><h3 id="2-重载运算符的规则"><a href="#2-重载运算符的规则" class="headerlink" title="2. 重载运算符的规则"></a>2. <strong>重载运算符的规则</strong></h3><ol><li>C++不允许用户自己定义新的运算符，只能对<code>已有</code>的运算符进行重载。</li><li>C++不允许重载的运算符<ul><li><code>.</code>    (成员访问运算符)</li><li><code>.*</code>    (成员指针访问运算符)</li><li><code>∷</code>    (域运算符)</li><li><code>sizeof</code> (长度运算符)</li><li><code>?:</code>    (条件运算符)</li></ul></li><li>重载<code>不能改变</code>运算符运算对象(即操作数)的<code>个数</code>。</li><li>重载<code>不能改变</code>运算符的<code>优先级和结合性</code>。</li><li>重载运算符的函数<code>不能有默认的参数</code>。</li><li>重载的运算符必须和用户自定义类型的对象一起使用，其参数<code>至少有一个</code>是类对象(或类对象的引用)。即参数不能全部是C++的标准类型。</li><li>用于类对象的运算符一般必须重载，但是运算符<code>“=”</code>和<code>“&amp;”</code>不需用户重载。</li><li>应当使重载运算符的功能类似于该运算符作用于标准类型数据时所实现的功能。</li><li>运算符重载函数可以是类的成员函数(如上例)，也可以是类的友元函数(全局友元函数)。</li></ol><h3 id="3-运算符重载函数作为类成员函数和友元函数"><a href="#3-运算符重载函数作为类成员函数和友元函数" class="headerlink" title="3. 运算符重载函数作为类成员函数和友元函数"></a>3. <strong>运算符重载函数作为类成员函数和友元函数</strong></h3><p>将“+”重载为适用于复数加法，重载函数为类的全局友元函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">friend</span> Complex <span class="keyword">operator</span> + (Complex &amp;c1,Complex &amp;c2);<span class="comment">//成员函数作为运算符重载函数的参数是？</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义作为友元函数的运算符重载函数</span></span><br><span class="line">Complex <span class="keyword">operator</span> + (Complex &amp;c1, Complex &amp;c2)&#123;</span><br><span class="line"><span class="keyword">return</span> Complex(c1.real+c2.real, c1.imag+c2.imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运算符重载函数的选择：</strong></p><ul><li>赋值运算符“=”、下标运算符“[]”、函数调用运算符“()”、成员运算符“-&gt;”<code>必须</code>作为<code>成员函数</code>重载。</li><li>流插入“&lt;&lt;”和流提取“&gt;&gt;”运算符、类型转换运算符不能定义为类的成员函数，<code>只能</code>做为<code>友元函数</code>。</li><li>一般将<code>单目</code>运算符和复合运算符重载为<code>成员函数</code>。</li><li>一般将<code>双目</code>运算符重载为<code>友元函数</code>。</li></ul><h3 id="4-重载双目运算符"><a href="#4-重载双目运算符" class="headerlink" title="4. 重载双目运算符"></a>4. <strong>重载双目运算符</strong></h3><p>定义一个字符串类String，用来存放不定长的字符串，重载运算符“==”“&lt;”“&gt;”，用于两个字符串的等于、小于和大于的比较运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">String</span>( )&#123; p=<span class="literal">NULL</span>; &#125;<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="keyword">String</span>( <span class="keyword">char</span> *str )&#123;<span class="comment">//带参数构造函数</span></span><br><span class="line">p=str;<span class="comment">//p指向实参字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">( )</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *p;<span class="comment">//字符型指针，用于指向字符串</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">String string1(″Hello″),  string2(″Book″);</span><br><span class="line">string1.<span class="built_in">display</span>( );string2.<span class="built_in">display</span>( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载运算符“&gt;”……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//声明运算符函数为友元函数,&lt;,==一样</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">String</span> &amp;string1,</span><br><span class="line">                                            <span class="keyword">String</span> &amp;string2);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt; (<span class="keyword">String</span> &amp;string1,<span class="keyword">String</span> &amp;string2) &#123;</span><br><span class="line"><span class="comment">//调用strcmp函数比较字符串大小</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(string1.p , string2.p)&gt;<span class="number">0</span>) <span class="comment">//&lt;,==</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-重载单目运算符"><a href="#5-重载单目运算符" class="headerlink" title="5. 重载单目运算符"></a>5. <strong>重载单目运算符</strong></h3><p>单目运算符只有一个操作数，因此运算符重载函数只有一个参数，如果运算符重载函数作为成员函数，则还可省略此参数。</p><p>有一个Time类，包含数据成员minute(分)和sec(秒)，模拟秒表，每次走一秒，满60秒进一分钟，此时秒又从0开始算。要求输出分和秒的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Time( )&#123;minute=<span class="number">0</span>;sec=<span class="number">0</span>;&#125;<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="comment">//构造函数重载，参数初始化表</span></span><br><span class="line">Time( <span class="keyword">int</span> m, <span class="keyword">int</span> s):minute(m), sec(s)&#123; &#125;</span><br><span class="line">Time <span class="keyword">operator</span>++( );<span class="comment">//前置++</span></span><br><span class="line">Time <span class="keyword">operator</span>++( <span class="keyword">int</span> );<span class="comment">//后置++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">( )</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;minute&lt;&lt;″:″&lt;&lt;sec&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> minute;  <span class="comment">//分</span></span><br><span class="line"><span class="keyword">int</span> sec;<span class="comment">//秒</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//前置++运算符重载函数</span></span><br><span class="line">Time Time∷<span class="keyword">operator</span>++( ) &#123; <span class="comment">//运算符重载函数实现部分</span></span><br><span class="line"><span class="keyword">if</span>(++sec&gt;=<span class="number">60</span>) &#123;<span class="comment">//每次执行++，sec+1</span></span><br><span class="line">sec-=<span class="number">60</span>;<span class="comment">//满60秒+1分钟，且sec-60</span></span><br><span class="line">++minute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回当前对象值</span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line"><span class="function">Time <span class="title">time1</span><span class="params">(<span class="number">34</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">61</span>;i++) &#123;</span><br><span class="line">++time1;</span><br><span class="line">time1.<span class="built_in">display</span>( );&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++运算符重载函数</span></span><br><span class="line">Time Time∷<span class="keyword">operator</span>++( <span class="keyword">int</span> ) &#123; </span><br><span class="line"><span class="function">Time <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;<span class="comment">//复制构造函数新建temp对象</span></span><br><span class="line"><span class="keyword">if</span>(++sec&gt;=<span class="number">60</span>) &#123;<span class="comment">//每次执行++，sec+1</span></span><br><span class="line">sec-=<span class="number">60</span>;<span class="comment">//满60秒+1分钟，且sec-60</span></span><br><span class="line">++minute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;<span class="comment">//返回当前对象值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>int参数只是表明此为后置++运算符重载函数，此外没其他作用，且在进行后置++时不需要传递参数。</p></li><li><p>this为当前对象的指针，*this即当前对象</p></li><li><p>通过对象调用函数后，此对象内的sec+1，但是temp保留+1之前的值，且返回的是temp对象，即sec+1之前的值。例如：</p><pre><code>time2=time1++; </code></pre></li></ul><h3 id="6-重载流插入运算符和流提取运算符"><a href="#6-重载流插入运算符和流提取运算符" class="headerlink" title="6. 重载流插入运算符和流提取运算符"></a>6. <strong>重载流插入运算符和流提取运算符</strong></h3><ul><li><p>输入流类：<code>istream</code>。输出流类：<code>ostream</code>。cin和cout分别是istream类和ostream类的对象。在类中已经对“&lt;&lt;”和“&gt;&gt;”进行了重载，能用来输出和输入C++<code>标准类型的数据</code>。</p></li><li><p><code>自定义类型</code>的数据不能直接用“&lt;&lt;”和“&gt;&gt;” ，须重载。</p></li><li><p>*<em>对“&lt;&lt;”和“&gt;&gt;”重载的函数形式如下： *</em></p></li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream  &amp; <span class="keyword">operator</span> &gt;&gt; (istream  &amp;, 自定义类 &amp;);</span><br><span class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;, 自定义类 &amp;);</span><br></pre></td></tr></table></figure></blockquote><p><strong>注：重载“&gt;&gt;”和“&lt;&lt;”的函数只能是友元函数。</strong></p><blockquote><p>假设用成员函数重载&lt;&lt;和&gt;&gt;，那么成员函数就只能本类对象才可以调用<br>，在使用&lt;&lt;/&gt;&gt;时必须写成：本类对象&lt;&lt;/&gt;&gt;cin/cout;<br>而不能写成:    cin&gt;&gt;s;     /    cout&lt;&lt;s;</p></blockquote><p>在前面Complex函数的基础上，用重载的“&lt;&lt;”输出复数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Complex( )&#123;real=<span class="number">0</span>;imag=<span class="number">0</span>;&#125;</span><br><span class="line">Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i)&#123;real=r;imag=i;&#125;</span><br><span class="line"><span class="comment">//运算符“+”重载为成员函数</span></span><br><span class="line">Complex <span class="keyword">operator</span> + (Complex &amp;c2);</span><br><span class="line"><span class="comment">//声明“&lt;&lt;”友元重载函数</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp;,Complex&amp;);     </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> real;</span><br><span class="line"><span class="keyword">double</span> imag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义运算符“&lt;&lt;”重载函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; output, <span class="keyword">const</span> Complex&amp; c) &#123; </span><br><span class="line">output&lt;&lt;″(″&lt;&lt;c.real&lt;&lt;″+″&lt;&lt;c.imag&lt;&lt;″i)″&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">Complex c1(2,4),c2(6,10),c3;</span><br><span class="line">c3=c1+c2;</span><br><span class="line"><span class="comment">//“cout&lt;&lt;c3”解释为operator&lt;&lt;(cout,c3)</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;c3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-标准类型数据间的转换"><a href="#7-标准类型数据间的转换" class="headerlink" title="7. 标准类型数据间的转换"></a>7. <strong>标准类型数据间的转换</strong></h3><p>隐式类型转换，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">6</span>; </span><br><span class="line">i = <span class="number">7.5</span> + i;</span><br></pre></td></tr></table></figure><p>显式类型转换。形式为： 类型名(数据)，例如：<code>int(89.5)</code></p><p>注意：C语言中的显式类型转换的格式为： <code>(int)89.5</code></p><h3 id="8-转换构造函数"><a href="#8-转换构造函数" class="headerlink" title="8. 转换构造函数"></a>8. <strong>转换构造函数</strong></h3><p>转换构造函数：作用是将一个<code>其他类型的数据</code>转换成一个<code>类的对象</code>。</p><p>转换构造函数只有一个形参，例如： <code>Complex(double r) { real=r; imag=0; }</code></p><p>使用转换构造函数将一个指定的数据转换为类对象的方法如下：</p><ol><li>先声明一个类。</li><li>在这个类中定义一个只有一个参数的构造函数，参数的类型是需要转换的类型，在函数体中指定转换的方法。</li><li>在该类的作用域内可以用以下形式进行类型转换：<code>类名(指定类型的数据)</code></li></ol><p>注：不仅可以将一个<code>标准类型</code>数据转换成类对象，也可以将另一个<code>类的对象</code>转换成转换构造函数所在的类对象。</p><p>例如：将一个学生类对象转换为教师类对象，Teacher类中的转换构造函数： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Teacher(Student&amp; s) &#123;</span><br><span class="line">num=s.num;  <span class="built_in">strcpy</span>(name,s.name);  sex=s.sex; &#125;</span><br></pre></td></tr></table></figure><p>注意： 对象s中的num,name,sex必须是公用成员，否则不能被类外引用</p><h3 id="9-类型转换函数"><a href="#9-类型转换函数" class="headerlink" title="9. 类型转换函数"></a>9. <strong>类型转换函数</strong></h3><p>转换构造函数：其他类型的数据类的对象</p><p>类型转换函数：类的对象其他类型的数据，注意，不是构造函数<br>    例如将一个Complex类对象转换成double类型数据</p><p>类型转换函数的一般形式为：</p><blockquote><p> operator 类型名( ) {</p><p>   实现转换的语句   }</p></blockquote><p>注意：</p><ul><li>在函数名前面不能指定函数类型，函数没有参数。其返回值的类型是由函数名中指定的类型名来确定的。</li><li>类型转换函数只能作为成员函数，因为转换的主体是本类的对象。不能作为友元函数或普通函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：Complex <span class="keyword">double</span>，在Complex类中定义类型转换函数： </span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> real;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐鉴赏</title>
      <link href="/posts/10591/"/>
      <url>/posts/10591/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note success">            <p>捕捉英文歌一首</p>          </div>    <div id="aplayer-KnpIhrBs" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1338809890" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><h1 id="音乐的语言"><a href="#音乐的语言" class="headerlink" title="音乐的语言"></a>音乐的语言</h1><p><strong>每个人的生活都不是单调的，都有无数情感，也许你正陷在繁冗的工作中，也许你正苦恼于这道题目到底该怎么解，也许你正沉浸于成功的喜悦，又或许你在抱怨生活遇到的不如意，而你又会真正把这些情感倾诉给谁听呢？随着年龄的增长，我们都渐渐都不愿随意表露自己的情感，而又很难遇到能把内心分享到人，但我们毕竟需要找到宣泄情感的途径，音乐就是这种情况下的一种产物。</strong></p><p><strong>诗言志，歌咏言，音乐是文学的一种重要表达形式，我们常常给一首音乐作品贴上标签，或壮美，或悲怆，或旷达，或欢快……而每一首作品都是作者内心最接触灵魂的情感表达，欣赏音乐，我们就像在用语言来沟通，当我们此刻的内心与音乐产生共鸣，就将两个灵魂紧紧地联系在了一起，无论是时间跨越多久，地域相隔多远，情感都能够互通，那种感觉，就好像你开车在高速路上，你的面前全是雾，现在突然消散的那种豁然开朗的感觉。那是一种自然的舒畅，无与伦比的清新，刹那间你会迷失在那乐曲里面，就像水在心头缓缓流过，其带来的震撼不逊于语言，诗词等。</strong></p><p><strong>课上我们欣赏了不少经典音乐，与其说音乐鉴赏，倒不如直接说听歌来的贴切，也许我无法欣赏到其中的美，但又被其中的旋律吸引，那种感觉就像是我听外国名人的英语演讲，虽然听不懂，但我竟然能沉迷于其表达，正如某位网友所说：“不要想，听就是了。“也许是从小就受到语文阅读理解教育的影响吧，我不喜欢听音乐时总要求听出什么哲理，表达的什么意图。感官的东西，去感受就是了，何必要用理性去破环自己的感受呢？只要自己听着舒服，何必想那么多，哪怕作者原本所表达的情感与我的感受完全是两码事，那也不妨碍我的陶醉。就像有的诗词、音乐、我就是特喜欢，但你又要问我为什么的话，我可能半天也不知道怎么回答，就是飞鸿踏雪泥般在心中留下了点痕迹，或是在某一瞬间有所感触，知道有就行了，也不需要表达不出来。</strong></p><p><strong>当然这也是只是我个人的一点偏见，不能否认音乐作品有它所蕴涵的深意。当你了解一首作品背后的故事，去亲近作者的话，你再去欣赏的话，就会有更深层次的理解，或许就可以真正达到与作品的灵魂沟通，跳出作品欣赏其整体美。给我印象最深刻的就是格什文的《蓝色狂想曲》，初次欣赏，我只是沉醉在其雄浑的齐奏，轻快的钢琴曲，富有变换的节奏中，然后了解到其中的一些乐器，有单簧管，号子，弦乐器，提琴，各种打击乐器等，勉强能分辨出是哪些乐器的声音后，再了解到作者创作的时代背景，知道表现的是美国经济经济萧条时期，我再去听，就下意识地找到了各个情感的一些流露，失业的人们要为自己的基本生活去不停地忙碌与奔波，为了争取工作丢掉了自尊、家庭、休息、爱好、以及可以让自己享受生活的一切，可换回来的仅仅只是让自己勉强维持生命的能力而已的悲惨的环境，来表达对现实许些不满的情感发泄，通过全面的了解，还是可以读出作品表达的内涵的。</strong></p><p><strong>无论是用个人的心情来理解音乐，还是实实在在了解作者表达的内涵，都不可否认音乐带来的效果，说它是一门语言，也不为过。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Homework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Valine设置邮件提醒和QQ提醒功能</title>
      <link href="/posts/8813/"/>
      <url>/posts/8813/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>南有仙地，名曰摩梭，摩梭有湖，泸沽是也。</p></blockquote>    <div id="aplayer-RhHKqqBq" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="28188425" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>刚开始的我对valine评论系统并不喜欢，谁喜欢在评论的时候填三个参数，不是应该越简单越好嘛，在Matery主题中用过一段时间后我就关了。之后启用了Gtalk模块，但它需要访客登录GitHub账号，而且博主需要在评论区登入GitHub初始化后访客才可以评论，较为不方便。然后到了Butterfly主题中恰好赶上主题的升级，其中优化支持了最新的valine的功能，我才知道valine更新了，而且有我需要的拉取QQ昵称头像功能，果断入手！</p></blockquote><h3 id="配置教程"><a href="#配置教程" class="headerlink" title="配置教程"></a>配置教程</h3><ol><li><p><a href="http://www.zhaojun.im/hexo-valine-admin/" target="_blank" rel="noopener">Hexo 优化 — Valine 扩展之邮件通知</a></p></li><li><p><a href="https://www.antmoe.com/posts/2380732b/index.html" target="_blank" rel="noopener">Hexo博客valine评论微信、qq提醒</a></p></li></ol><p>按照两篇大佬文章就可以了，教程挺详尽的，我就不做叙述了。</p><h3 id="插件链接"><a href="#插件链接" class="headerlink" title="插件链接"></a>插件链接</h3><p><a href="https://qmsg.zendee.cn/" target="_blank" rel="noopener">Qmsg酱</a></p><h3 id="对于文章中首先需要确保-Valine-的基础功能是正常的理解："><a href="#对于文章中首先需要确保-Valine-的基础功能是正常的理解：" class="headerlink" title="对于文章中首先需要确保 Valine 的基础功能是正常的理解："></a>对于文章中<code>首先需要确保 Valine 的基础功能是正常的</code>理解：</h3><p>每个主题中都有valine的集成，我们只要在主题配置文件中对应valine配置中<code>enable</code>、<code>appId</code>、<code>appKey</code>填写正确就行。对我们小白来说，只要在进行优化前，评论可以正常使用就完全🆗了。</p><h3 id="valine更新的问题（请忽略）"><a href="#valine更新的问题（请忽略）" class="headerlink" title="valine更新的问题（请忽略）"></a><del>valine更新的问题</del>（请忽略）</h3><p>我在Matery的主题配置文件中看到valine的js地方有这样一句话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valine: https:&#x2F;&#x2F;unpkg.com&#x2F;valine&#x2F;dist&#x2F;Valine.min.js # 若想保持最新版，请替换为 https:&#x2F;&#x2F;unpkg.com&#x2F;valine&#x2F;dist&#x2F;Valine.min.js  默认为 &#x2F;libs&#x2F;valine&#x2F;Valine.min.js</span><br></pre></td></tr></table></figure><p>Butterfly中并未做说明,所以我尝试着把Butterfly配置中Valine的CDN地址改成了<code>https://unpkg.com/valine/dist/Valine.min.js</code>发现Valine就发更新到最新了。</p><p>至于我为什么会找这个问题， 是因为<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine官方的文档</a>已经指出最新版已经支持了拉取QQ昵称、邮箱和头像的功能，这就不需要我再取找魔改教程了😂，而我的valine还是以前的一个版本</p><div class="note info">            <p>好吧，可能我是个特例，今天重新配置的时候发现并不需要修改，butterfly.yml本就是最新的。</p>          </div><h3 id="小提醒"><a href="#小提醒" class="headerlink" title="小提醒"></a>小提醒</h3><p>要把主题配置中valine的<code>enableQQ</code>设置为<code>true</code>才会有拉取QQ信息的效果哦~</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Valine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo添加说说页面</title>
      <link href="/posts/23519/"/>
      <url>/posts/23519/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>其实,不是每次抬头都能看见云的,每次都能看见的,是天。</p><p align="right">  ——《雪见—仙凡之旅》网易云音乐热评</p> </blockquote>    <div id="aplayer-gWdVUVaY" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="86381" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><blockquote><p>​        昨天吃完饭的时候突然想到是不是可以在博客上开辟出一个标签页用来发表个人说说，记录自己的生活，就像QQ空间一样呢?（以前由于不喜欢花里胡哨及无聊的广告就把QQ的空间给关掉了）于是我吃完饭立即在网上展开相关资料的搜索，最终将目标锁定在Uncle_drew的一个项目上，biu~~<a href="https://cndrew.cn/2020/04/10/hexo-shuoshuo/" target="_blank" rel="noopener">博客教程传送门</a>。（里面也有GitHub仓库和视频教程）</p></blockquote><blockquote><h3 id="说明：我没有写出步骤，只是列出我的一些问题供参考，具体步骤请移步作者博客及GitHub仓库。"><a href="#说明：我没有写出步骤，只是列出我的一些问题供参考，具体步骤请移步作者博客及GitHub仓库。" class="headerlink" title="说明：我没有写出步骤，只是列出我的一些问题供参考，具体步骤请移步作者博客及GitHub仓库。"></a>说明：我没有写出步骤，只是列出我的一些问题供参考，具体步骤请移步作者博客及GitHub仓库。</h3></blockquote><div class="note warning">            <p><strong>由于我配置的时候早了点，现在作者已经将该项目改名为Artitalk并发布了<a href="https://artitalk.js.org/" target="_blank" rel="noopener">新的文档</a>，所以我的这篇文章应该过时了，不过也可以参考可参考，之后我会按照新的文档重新配置试试。</strong></p>          </div><p>​        原本他是创建的一个静态说说页面，但由于每次写说说的时候都需要在本地撰写，然后再部署发布，很不方便，于是他便想实现实时发布的动态效果，虽然实现了但有些不知名的bug，不过总体还算可以。由于看了作者的博客，GitHub和B站上教程，多少都是有差异的，而且教程上有些表达不清，倒是给我带来了不少问题，我把一些主要的问题列出来：</p><blockquote><h3 id="1-GitHub上下载的文件压缩后只需取其中的scr文件夹-然后放到-theme-你的主题-source-就好。"><a href="#1-GitHub上下载的文件压缩后只需取其中的scr文件夹-然后放到-theme-你的主题-source-就好。" class="headerlink" title="1. GitHub上下载的文件压缩后只需取其中的scr文件夹,然后放到/theme/你的主题/source/就好。"></a>1. GitHub上下载的文件压缩后只需取其中的<code>scr</code>文件夹,然后放到<code>/theme/你的主题/source/</code>就好。</h3></blockquote><blockquote><h3 id="2-作者博客上让你写在index-md的代码"><a href="#2-作者博客上让你写在index-md的代码" class="headerlink" title="2. 作者博客上让你写在index.md的代码"></a>2. 作者博客上让你写在<code>index.md</code>的代码<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/jankin6/picgo-picture/Imges/image-20200428134528418.png" alt=""></h3></blockquote><p>需添加的部分如下：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/jankin6/picgo-picture/Imges/image-20200428140259342.png" alt=""></p><h4 id="其次注意上图中"><a href="#其次注意上图中" class="headerlink" title="其次注意上图中"></a>其次注意上图中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#x2F;src&#x2F;shuoshuov1.1.css&quot; media&#x3D;&quot;all&quot;&gt;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;src&#x2F;os.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;src&#x2F;shuoshuov2.1.1.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>href=&quot;/src/shuoshuov1.1.css</code>等号后面的路径的意思就是调用<code>source文件夹</code>里面的<code>scr文件夹</code>里面的<code>shuoshuov1.1.css</code>文件，所以我刚才建议你直接把<code>scr</code>文件夹直接放在<code>/theme/你的主题/source/</code>。（当然你也可以自定义放置，但上图中的路径要对应好）下面两行引用代码的注意点同上。</p><blockquote><p>上图中新增的代码在作者的GitHub仓库下面都给出了。</p></blockquote><blockquote><h3 id="3-对于作者说的在head中调用font-awesome的css"><a href="#3-对于作者说的在head中调用font-awesome的css" class="headerlink" title="3. 对于作者说的在head中调用font-awesome的css"></a>3. 对于作者说的<code>在head中调用font-awesome的css</code></h3></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/jankin6/picgo-picture/Imges/image-20200428141532473.png" alt=""></p><p>我的主题为Butterfy，我实现的方式是在主题配置文件butterfly.yml中添加这段代码，其他的我就不知道了（小白勿喷）😟</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/jankin6/picgo-picture/Imges/image-20200428141741826.png" alt=""></p><blockquote><h3 id="4-如下的代码是loading-page的加载动画，不好看所以我删掉了。"><a href="#4-如下的代码是loading-page的加载动画，不好看所以我删掉了。" class="headerlink" title="4. 如下的代码是loading-page的加载动画，不好看所以我删掉了。"></a>4. 如下的代码是loading-page的加载动画，不好看所以我删掉了。</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;lazy&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;preloader&quot; style&#x3D;&quot;opacity: 1; &quot;&gt;</span><br><span class="line">  &lt;svg version&#x3D;&quot;1.1&quot; id&#x3D;&quot;sun&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; xmlns:xlink&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xlink&quot; x&#x3D;&quot;0px&quot; y&#x3D;&quot;0px&quot; width&#x3D;&quot;10px&quot; height&#x3D;&quot;10px&quot; viewBox&#x3D;&quot;0 0 10 10&quot; enable-background&#x3D;&quot;new 0 0 10 10&quot; xml:space&#x3D;&quot;preserve&quot; style&#x3D;&quot;opacity: 1; margin-left: 0px; margin-top: 0px;&quot;&gt;</span><br><span class="line">    &lt;g&gt;</span><br><span class="line">      &lt;path fill&#x3D;&quot;none&quot; d&#x3D;&quot;M6.942,3.876c-0.4-0.692-1.146-1.123-1.946-1.123c-0.392,0-0.779,0.104-1.121,0.301c-1.072,0.619-1.44,1.994-0.821,3.067C3.454,6.815,4.2,7.245,5,7.245c0.392,0,0.779-0.104,1.121-0.301C6.64,6.644,7.013,6.159,7.167,5.581C7.321,5,7.243,4.396,6.942,3.876z M6.88,5.505C6.745,6.007,6.423,6.427,5.973,6.688C5.676,6.858,5.34,6.948,5,6.948c-0.695,0-1.343-0.373-1.69-0.975C2.774,5.043,3.093,3.849,4.024,3.312C4.32,3.14,4.656,3.05,4.996,3.05c0.695,0,1.342,0.374,1.69,0.975C6.946,4.476,7.015,5,6.88,5.505z&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class="line">      &lt;path fill&#x3D;&quot;none&quot; d&#x3D;&quot;M8.759,2.828C8.718,2.757,8.626,2.732,8.556,2.774L7.345,3.473c-0.07,0.041-0.094,0.132-0.053,0.202C7.319,3.723,7.368,3.75,7.419,3.75c0.025,0,0.053-0.007,0.074-0.02l1.211-0.699C8.774,2.989,8.8,2.899,8.759,2.828z&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class="line">      &lt;path fill&#x3D;&quot;none&quot; d&#x3D;&quot;M1.238,7.171c0.027,0.047,0.077,0.074,0.128,0.074c0.025,0,0.051-0.008,0.074-0.02l1.211-0.699c0.071-0.041,0.095-0.133,0.054-0.203S2.574,6.228,2.503,6.269l-1.21,0.699C1.221,7.009,1.197,7.101,1.238,7.171z&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class="line">      &lt;path fill&#x3D;&quot;none&quot; d&#x3D;&quot;M6.396,2.726c0.052,0,0.102-0.026,0.13-0.075l0.349-0.605C6.915,1.976,6.89,1.885,6.819,1.844c-0.07-0.042-0.162-0.017-0.202,0.054L6.269,2.503C6.228,2.574,6.251,2.666,6.322,2.706C6.346,2.719,6.371,2.726,6.396,2.726z&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class="line">  &lt;path fill&#x3D;&quot;none&quot; d&#x3D;&quot;M3.472,7.347L3.123,7.952c-0.041,0.07-0.017,0.162,0.054,0.203C3.2,8.169,3.226,8.175,3.25,8.175c0.052,0,0.102-0.027,0.129-0.074l0.349-0.605c0.041-0.07,0.017-0.16-0.054-0.203C3.603,7.251,3.513,7.276,3.472,7.347z&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class="line">  &lt;path fill&#x3D;&quot;none&quot; d&#x3D;&quot;M3.601,2.726c0.025,0,0.051-0.007,0.074-0.02C3.746,2.666,3.77,2.574,3.729,2.503l-0.35-0.604C3.338,1.828,3.248,1.804,3.177,1.844C3.106,1.886,3.082,1.976,3.123,2.047l0.35,0.604C3.5,2.7,3.549,2.726,3.601,2.726z&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class="line">  &lt;path fill&#x3D;&quot;none&quot; d&#x3D;&quot;M6.321,7.292c-0.07,0.043-0.094,0.133-0.054,0.203l0.351,0.605c0.026,0.047,0.076,0.074,0.127,0.074c0.025,0,0.051-0.006,0.074-0.02c0.072-0.041,0.096-0.133,0.055-0.203l-0.35-0.605C6.483,7.276,6.393,7.253,6.321,7.292z&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class="line">  &lt;path fill&#x3D;&quot;none&quot; d&#x3D;&quot;M2.202,5.146c0.082,0,0.149-0.065,0.149-0.147S2.284,4.851,2.202,4.851H1.503c-0.082,0-0.148,0.066-0.148,0.148s0.066,0.147,0.148,0.147H2.202z&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class="line">  &lt;path fill&#x3D;&quot;none&quot; d&#x3D;&quot;M8.493,4.851H7.794c-0.082,0-0.148,0.066-0.148,0.148s0.066,0.147,0.148,0.147l0,0h0.699c0.082,0,0.148-0.065,0.148-0.147S8.575,4.851,8.493,4.851L8.493,4.851z&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class="line">  &lt;path fill&#x3D;&quot;none&quot; d&#x3D;&quot;M5.146,2.203V0.805c0-0.082-0.066-0.148-0.148-0.148c-0.082,0-0.148,0.066-0.148,0.148v1.398c0,0.082,0.066,0.149,0.148,0.149C5.08,2.352,5.146,2.285,5.146,2.203z&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class="line">  &lt;path fill&#x3D;&quot;none&quot; d&#x3D;&quot;M4.85,7.796v1.396c0,0.082,0.066,0.15,0.148,0.15c0.082,0,0.148-0.068,0.148-0.15V7.796c0-0.082-0.066-0.148-0.148-0.148C4.917,7.647,4.85,7.714,4.85,7.796z&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class="line">  &lt;path fill&#x3D;&quot;none&quot; d&#x3D;&quot;M2.651,3.473L1.44,2.774C1.369,2.732,1.279,2.757,1.238,2.828C1.197,2.899,1.221,2.989,1.292,3.031l1.21,0.699c0.023,0.013,0.049,0.02,0.074,0.02c0.051,0,0.101-0.026,0.129-0.075C2.747,3.604,2.722,3.514,2.651,3.473z&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class="line">  &lt;path fill&#x3D;&quot;none&quot; d&#x3D;&quot;M8.704,6.968L7.493,6.269c-0.07-0.041-0.162-0.016-0.201,0.055c-0.041,0.07-0.018,0.162,0.053,0.203l1.211,0.699c0.023,0.012,0.049,0.02,0.074,0.02c0.051,0,0.102-0.027,0.129-0.074C8.8,7.101,8.776,7.009,8.704,6.968z&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class="line">  &lt;&#x2F;g&gt;</span><br><span class="line">  &lt;&#x2F;svg&gt;</span><br><span class="line"></span><br><span class="line">  &lt;svg version&#x3D;&quot;1.1&quot; id&#x3D;&quot;cloud&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; xmlns:xlink&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xlink&quot; x&#x3D;&quot;0px&quot; y&#x3D;&quot;0px&quot; width&#x3D;&quot;10px&quot; height&#x3D;&quot;10px&quot; viewBox&#x3D;&quot;0 0 10 10&quot; enable-background&#x3D;&quot;new 0 0 10 10&quot; xml:space&#x3D;&quot;preserve&quot;&gt;</span><br><span class="line">    &lt;path fill&#x3D;&quot;none&quot; d&#x3D;&quot;M8.528,5.624H8.247c-0.085,0-0.156-0.068-0.156-0.154c0-0.694-0.563-1.257-1.257-1.257c-0.098,0-0.197,0.013-0.3,0.038C6.493,4.259,6.45,4.252,6.415,4.229C6.38,4.208,6.356,4.172,6.348,4.131C6.117,3.032,5.135,2.235,4.01,2.235c-1.252,0-2.297,0.979-2.379,2.23c-0.004,0.056-0.039,0.108-0.093,0.13C1.076,4.793,0.776,5.249,0.776,5.752c0,0.693,0.564,1.257,1.257,1.257h6.495c0.383,0,0.695-0.31,0.695-0.692S8.911,5.624,8.528,5.624z&quot;&gt;&lt;&#x2F;path&gt;</span><br><span class="line">  &lt;&#x2F;svg&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class&#x3D;&quot;rain&quot;&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;drop&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;drop&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;drop&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;drop&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;drop&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;drop&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;drop&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;drop&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;drop&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;drop&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;text&quot;&gt;</span><br><span class="line">    LOOKING OUTSIDE FOR YOU... ONE SEC</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><ul><li>还有个小问题就是我的加载动画会和说说冲突，可能是个bug吧，我把自己添加的加载动画删除了，说说页面就可以正常显示了，不然就一直是我的那个加载动画😥</li></ul><blockquote><h3 id="★5月6号更新"><a href="#★5月6号更新" class="headerlink" title="★5月6号更新"></a>★5月6号更新</h3></blockquote><p><code>更新后的使用更加简便，直接粘贴复制就可使用，代码精简化，功能更多，且支持markdown语法,页面漂亮了许多，期待作者更多的开发，若不是我对前端知识不太了解，我都想加入一起完善这个功能了😉。</code></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 说说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建及Matery和Butterfly主题配置经历</title>
      <link href="/posts/25313/"/>
      <url>/posts/25313/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>校长说，奋斗真的只是因为 好吃的很贵，远方很远，喜欢的人很优秀 。        </p><p align="right">——《烟火焚》网易云音乐热评</p> </blockquote>    <div id="aplayer-tHooVmZQ" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1309443665" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>  ​        我最初的想法并不是搭建个博客，网上也是可以找些博客平台的，但我又不太喜欢各大平台的限制和无孔不入的广告，偶然机会访问了一个QQ群主的博客，感觉挺有意思，之后看到<a href="https://developer.aliyun.com/adc/student/?pid=mm_25282911_3455987_122436732" target="_blank" rel="noopener">阿里云高校学生“在家实践”计划</a>也跟着领了6个月的服务器，折腾了会发现不会用啊，就让它落灰去了，然后看到这个可以用来搭建博客，突然兴趣就上来了，反正上网课也是无聊，搜集些资料后发现用服务器的话成本太高，就决定试试免费的Hexo，从此一发不可收拾，所谓一时折腾一时爽，一直折腾一直爽！我从什么是git都不知道的情况下慢慢能够迅速搭建出个Hexo并解决一些常见问题，这时我才发现，真正折腾人的，是主题的优化！</p></blockquote><div class="note info">            <p>我没有详细列出Hexo搭建和主题配置的步骤，只是简单记录自己的学习经历，踩到的小坑坑和主题的优化，并汇总参阅的一些价值较高的文档。</p>          </div><h1 id="参阅资料及历程简记"><a href="#参阅资料及历程简记" class="headerlink" title="参阅资料及历程简记"></a>参阅资料及历程简记</h1><p>Hexo的<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档中文版</a>   (其实我并没有仔细阅读过，主要根据大佬们写的博客一步步走的)</p><ol><li><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty" target="_blank" rel="noopener">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a></p></li><li><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">hexo史上最全搭建教程</a></p></li></ol><p>这两个算是我的启蒙教材，不过视频作者是用的<code>Mac</code>平台，部分的操作和Windows还是不一样的，我倒是踩了不少坑，不过倒是对搭建的过程有了一些基础，然后找到了csdn上的一篇文献，是在Windows系统上的，所以跟着步骤做很快就搭建并配置出最原始的博客。</p><hr><p>至于主题的选取也是耗费了一段时间，找到一款适合的还真不容易，最终选取了Matery主题，第一眼就被色彩和布局吸引了，果断下载！</p><p>作者的<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">主题仓库介绍</a>里面给出了详细的配置教程。</p><p>另外还有Yanfine大佬<a href="https://yafine66.gitee.io/posts/4ab2.html" target="_blank" rel="noopener">Hexo+github搭建博客(超级详细版，精细入微)</a>的文档，里面把从环境准备，到博客搭建，再到Matery主题的配置都一步步列出来了，很是推荐！</p><p>此外点击Yanfine博客的<a href="https://yafine-blog.cn/" target="_blank" rel="noopener">主页</a>你可以发现还有许多自定制修改文章，以及免费图床、码云coding部署。</p><p>致敬大佬！</p><hr><p>折腾了近一星期后又发现了Butterfly主题，于是就叛变了，开始研究新主题，但我依旧是Matery的粉丝。</p><p>Butterfly<a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">主题仓库</a></p><p>作者的<a href="https://jerryc.me/" target="_blank" rel="noopener">配置文档</a></p><p>第三方的配置文档<a href="https://www.lucfzy.com/2020/02/butterfly-theme/#Page-Front-matter" target="_blank" rel="noopener">Hexo-Theme-Butterfly快速入门及全面配置优化</a></p><p>两篇文档差不多，但后者对语言和配置做了些许优化整合，对零基础爱好者更友好。</p><hr><h1 id="那些碰到的问题"><a href="#那些碰到的问题" class="headerlink" title="那些碰到的问题"></a>那些碰到的问题</h1><div class="note default">            <p>由于从开始接触Hexo，到安装和主题配置，整个过程前后约有一个多星期，时间长问题多，所以不可能把所有经历过问题都能列出来，对于一些问题由于当时并未截图保存，所以也无法清楚地阐述。</p>          </div><hr><h2 id="1-Hexo搭建"><a href="#1-Hexo搭建" class="headerlink" title="1. Hexo搭建"></a>1. Hexo搭建</h2><p>前面也说过了，刚开始学习的时候也是不知道该如何开始，就想着找个视频教程来得方便，于是入坑了b站上的一个叫codesheep的教程视频，虽然是mac版的，但视频的弹屏和下面的评论也有些与视频教程对应的Windows平台的步骤，解决了一些指令错误的问题。</p><blockquote><p>所有git指令都是在博客的根目录中实现的，执行完<code>hexo init xx</code>后要进入<code>xx</code>里面再做后续操作。</p></blockquote><blockquote><p> 如果出现一些问题或是不想要了直接把创建的文件夹<code>xx</code>一整块都给删了就行，然后重做。（为提高一次性成功率我开始都是在虚拟机里面操作的，后面才知道其实没什么影响，直接在电脑上做就行）</p></blockquote><blockquote><p>初始化和主题下载的时候由于一些原因可能会卡住，直接删掉重来😆</p></blockquote><blockquote><p>GitHub对应仓库的名称一定要是<code>用户名.github.io</code></p></blockquote><blockquote><p>在git里面需要右键选择<code>paste</code>来粘贴你所复制的指令，有时候从网上复制git指令的时候会包含个回车，就是你粘贴后光标会自动转到下一行，有时候就相当于你按了回车，有时候指令会失效。</p></blockquote><hr><h2 id="2-无奈的错误"><a href="#2-无奈的错误" class="headerlink" title="2. 无奈的错误"></a>2. 无奈的错误</h2><blockquote><p><strong>我犯了一个细节错误，主题中需要新建的<code>_data</code>文件夹我搞成了<code>_date</code>，在该主题下并未发现问题，应该是里面只存放了<code>friends.json</code>文件，而我并没有怎么配置友链的原因吧！但是在Butterfly主题中，由于Buttefly采用了平滑升级的模式，需要把配置文件复制并改名放在_data中，因此只需修改<code>_date</code>中的配置文件就能达到对主题设置的同样效果，我尝试太多次都出现许多报错，折腾了四个多小时后偶然的机会在群友的帮助下找出问题，当时真的是又可笑又无奈😔</strong></p></blockquote><h2 id="3-Matery主题"><a href="#3-Matery主题" class="headerlink" title="3. Matery主题"></a>3. Matery主题</h2><ul><li><p>新建tags，categories ，about，contact等页面时，我看到压饭大佬给出的内容是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2018-09-30 17:25:30</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>然后我直接复制粘贴到我新建的对应界面，由于并未选择<code>粘贴为纯文本</code>导致只是粘贴的代码，并不是应有的<code>Front-matter</code>,导致运行时点击<code>标签</code>，<code>分类</code>，<code>关于</code>等页面时<em>无法导航到对应界面</em>。正确做法是直接在自己新建的<code>md文件</code>中手动打出来，或者粘贴为纯文本，但都要注意是在<code>Front-matter</code>即原本生成的给你的框框里面。（后来想了想，压饭给出的应该是源代码模式下的md内容，只要我也在源代码模式下，就是可以直接复制粘贴的—-源代码模式与普通视图的切换在<code>视图/源代码模式</code>里面）</p></li><li><p>对于图片懒加载之后<a href="https://yafine-blog.cn/posts/fc0.html" target="_blank" rel="noopener">击首页<strong>logo</strong>不是跳转到首页，而是查看<strong>logo</strong>图片</a>问题的解决方案中，修改主题的<code>header.ejs</code>文件时我错误地将第二个添加的元素误认为也是<code>&lt;div&gt;</code>（应该是<code>&lt;/div&gt;</code>），导致主页排版出现混乱，困扰良久😖(后来想想，但凡有点html基础常识我也不至于这么折腾！)</p></li></ul><h2 id="4-Butterfly主题"><a href="#4-Butterfly主题" class="headerlink" title="4. Butterfly主题"></a>4. Butterfly主题</h2><ul><li><p>有了前面那么些天的折腾基础，换主题还是很简单的，但我第一次碰到需要使用 <a href="https://hexo.io/docs/data-files.html" target="_blank" rel="noopener">data files</a> 特性的主题，有点不知所措，折腾之后也就明白了，其实就是在<code>_data/butterfly.yml</code>中对主题作配置，之后需要升级的时候，直接下载整个主题包，替换原本的整个主题文件夹，然后将新的主题配置文件与<code>_data/butterfly.yml</code>比较来进行增删。当然前提是你并没有进行魔改，如果你在原本的主题文件中做了处理修改，那么就需要重新修改了，但总体还是比较方便的。</p></li><li><p>主题需要装渲染器的，所以<code>hexo s</code>后发现只有一两行英文时不要惊讶，按文档要求装上。</p></li><li><p>另外大多数问题都是没有装插件导致的，所以在配置文件中你改每个<code>false</code>为<code>true</code>的时候都要注意文档中有没有给出需要装插件的要求。</p></li><li><p>主题文档中对<code>Front-matter</code>的配置那里有个地方少了个<code>:</code>所以修改后<code>hexo g</code>会报错，注意加上就好了。</p></li></ul><h1 id="链接直达"><a href="#链接直达" class="headerlink" title="链接直达"></a>链接直达</h1><ol><li><p>图标网址<a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a> </p></li><li><p>天气插件生成<a href="https://cj.weather.com.cn/" target="_blank" rel="noopener">中国天气官网</a></p></li><li><p>Valine管理<a href="https://leancloud.cn/dashboard/login.html#/signin" target="_blank" rel="noopener">LeanCloud</a></p></li><li><p>访客地图<a href="https://clustrmaps.com/" target="_blank" rel="noopener">clustrmaps</a> </p></li><li><p>图片上传工具<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">PicGo</a></p></li></ol><h1 id="主题美化相关"><a href="#主题美化相关" class="headerlink" title="主题美化相关"></a>主题美化相关</h1><ol><li><a href="https://www.antmoe.com/posts/1dc865d0/" target="_blank" rel="noopener">页脚渐变颜色</a>，背景，鼠标样式，也可参考下。</li><li></li></ol><h1 id="插件补充"><a href="#插件补充" class="headerlink" title="插件补充"></a>插件补充</h1><ol><li>文章链接简短：<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">abbrlink</a> <code>npm install hexo-abbrlink --save</code></li><li>音乐播放器：<a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">aplayer</a>  <code>npm install --save hexo-tag-aplayer</code></li><li>添加卡通人物(看板娘)：<code>npm install --save hexo-helper-live2d</code>      <a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">模型选择</a></li><li>豆瓣插件 <code>npm install hexo-douban --save</code></li><li></li></ol><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><blockquote><p>Hexo的搭建过程倒是能磨磨我的耐心，是会有很多问题的，而我对前端知识并未涉猎，那种感觉就像我不听物理课，然后还要交物理作业那样，唯一的区别就是我对物理没兴趣。然后还有很多不知名的错误，怎么说呢，就像这样：<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/jankin6/picgo-picture/Imges/TIM%E6%88%AA%E5%9B%BE20200506164830.png" alt=""><br>哈哈，我感觉还是可以有很多个性化问题的，比如对文档的理解以及安装环境等其它各种不确定因素（当然，这只是对我这种先前对相关知识并无了解毫无经验的人），这就需要坐下来慢慢折腾，参考别人的经验，不断地用搜索引擎。不了解的知识就去学嘛，不想学就按照别人的教程跟着走嘛，不求甚解，求一知半解也是可以的啊，这都需要花时间精力的，但总比我花在娱乐上强嘛，回想起来，这一天折腾下来还真跟我以前打一天的游戏感觉差不多呢！其实吧，这个的意义还真就在于搭建优化的过程，有这时间还不如去个现成的平台呢。生命不息，折腾不止，<code>折腾</code>，或许是我前进的动力吧！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matery </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typroa语法小记</title>
      <link href="/posts/59407/"/>
      <url>/posts/59407/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>“你和萤火虫有两个共同点，在我的眼里都会发光，同时，都已经很多年没见了。”</p><p align="right">——《夜、萤火虫和你》网易云音乐热评</p></blockquote>    <div id="aplayer-qjPmtFRV" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="509720124" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><h2 id="1-多级标题"><a href="#1-多级标题" class="headerlink" title="1. 多级标题"></a>1. 多级标题</h2><p>方法一： <code>#</code>加上<code>空格</code></p><p><code># 这是第一级标题</code></p><p><code>## 这是第二级标题</code></p><p>方法二：快捷键：<code>ctrl+ 1~6</code>       清除<code>ctrl+ 0</code></p><p>方法三：选择文字后点击菜单栏<code>段落</code>选择标题级数</p><h2 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表</h2><h3 id="1-有序列表"><a href="#1-有序列表" class="headerlink" title="1. 有序列表"></a>1. 有序列表</h3><p>语法： 数字加<code>.</code>加空格   <code>1.</code>      </p><p>快捷键：<code>ctrl+shift+[</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行末回车序号会自动添加  回车加回车会取消序号</span><br><span class="line">行末↓，序号不自动添加</span><br></pre></td></tr></table></figure><p>有序列表中嵌套有序列表 <code>-&gt;</code>选择后按<code>tab</code>键实现降级</p><p>按<code>shift+tab</code>实现升级</p><h3 id="2-无序列表"><a href="#2-无序列表" class="headerlink" title="2. 无序列表"></a>2. 无序列表</h3><p>语法：加空格  / -加空格    <code>*</code></p><p>快捷键：<code>ctrl+shift+]</code></p><ol><li><p>青菜</p></li><li><p>水果</p><ul><li>苹果</li><li>菠萝</li></ul><p>选择后按<code>tab</code>实现降级</p></li></ol><h3 id="3-有序与无序的切换"><a href="#3-有序与无序的切换" class="headerlink" title="3. 有序与无序的切换"></a>3. 有序与无序的切换</h3><p>有序快捷键：<code>ctrl+shift+[</code></p><p>无序快捷键：<code>ctrl+shift+]</code></p><p>配合<code>tab</code>和<code>shift+tab</code></p><p>实现无序与有序的交错使用</p><p>有序与无序也可以选择后在菜单<code>段落</code>中选择<code>有序列表</code>和<code>无序列表</code></p><h3 id="4-任务列表"><a href="#4-任务列表" class="headerlink" title="4. 任务列表"></a>4. 任务列表</h3><p>  语法：<code>-</code>加<code>空格</code>加<code>[</code>加<code>空格</code>加<code>]</code>加<code>空格</code>       <code>- [ ]</code></p><p>  还需在开头，如果前面有文字就无法实现</p><ul><li><input disabled="" type="checkbox"> <p>任务一</p></li><li><input disabled="" type="checkbox"> <p>任务二</p></li><li><input disabled="" type="checkbox"> <p>任务三</p><p>回车加回车取消任务列表</p><p>方法二：选择后点击菜单<code>段落</code>选择<code>任务列表</code></p></li></ul><h2 id="3-插入表格"><a href="#3-插入表格" class="headerlink" title="3. 插入表格"></a>3. 插入表格</h2><p>语法：<code>|</code>加<code>xx</code>加<code>|</code>…然后回车就行</p><p>快捷键：<code>ctrl+t</code></p><p>在表格中点击任意单元通过快捷键<code>ctrl+回车</code>即可添加新的一行</p><h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h2><h3 id="1-行内代码"><a href="#1-行内代码" class="headerlink" title="1. 行内代码"></a>1. 行内代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过两个`  可以将选中的文字转为代码，</span><br><span class="line">也可选择文字后用快捷键   ==ctrl+shift+`==快捷转化为代码</span><br></pre></td></tr></table></figure><h3 id="2-代码块"><a href="#2-代码块" class="headerlink" title="2. 代码块"></a>2. 代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">创建方式：```java</span><br><span class="line">ctrl+shift+k可以快捷创建代码块，在右下角选择语言</span><br></pre></td></tr></table></figure><h2 id="5-插入图片"><a href="#5-插入图片" class="headerlink" title="5. 插入图片"></a>5. 插入图片</h2><p>粗暴的直接拖拽</p><p>语法创建：<code>![自定义图片名字](地址)</code></p><p>快捷键：<code>ctrl+shift+i</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![cool](https:<span class="comment">//cdn.jsdelivr.net/gh/jankin6/picgo-picture/Imges/abd08161p00q7290r00wqc000xc00ilc.png)</span></span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/jankin6/picgo-picture/Imges/abd08161p00q7290r00wqc000xc00ilc.png" alt="cool"></p><h2 id="6-加粗，倾斜，删除线，下划线，高亮，上下标"><a href="#6-加粗，倾斜，删除线，下划线，高亮，上下标" class="headerlink" title="6. 加粗，倾斜，删除线，下划线，高亮，上下标"></a>6. 加粗，倾斜，删除线，下划线，高亮，上下标</h2><ul><li><p><code>**加粗**</code>                       <strong>加粗</strong></p></li><li><p><code>*倾斜*</code>                            <em>倾斜</em></p></li><li><p><code>加粗倾斜</code>                         <strong><em>加粗倾斜</em></strong></p></li><li><p><code>~~删除线~~</code>                     <del>删除线</del></p></li><li><p>下划线快捷键<code>ctrl+u</code>     <u>下划线</u></p></li><li><p><code>==高亮==</code>                         ==高亮== （不过好像在网页上并未显示出高亮效果）</p></li><li><p><code>^上标^</code>                             ^上标^</p></li><li><p><code>~下标~</code>                             <del>下标</del>      </p></li><li><p><code>---</code>                                分割线       也可<code>***</code>,<code>___</code></p></li></ul><hr><h2 id="7-引用，表情符号，实空心点"><a href="#7-引用，表情符号，实空心点" class="headerlink" title="7. 引用，表情符号，实空心点"></a>7. 引用，表情符号，实空心点</h2><ul><li>引用1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用</span><br><span class="line">&gt;&gt;第二级</span><br><span class="line">&gt;&gt;&gt;第三级</span><br></pre></td></tr></table></figure><blockquote><p>引用</p><blockquote><p>第二级</p><blockquote><p>第三级</p></blockquote></blockquote></blockquote><ul><li>引用2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&quot;试试看喽&quot;</span><br></pre></td></tr></table></figure><blockquote><p>“试试看喽”</p></blockquote><ul><li>表情符号</li></ul><p>输入<code>:xxx:</code> </p><p>一些常用例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile:  :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary:</span><br><span class="line"></span><br><span class="line">:+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger:</span><br></pre></td></tr></table></figure><p>:smile:  :laughing:  :dizzy_face:   :sob:   :sweat_smile:   :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary: :+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger:</p><ul><li><p>实空心点  </p></li><li><p>+号和空格</p><ul><li>回车，再回车，可以消除实心点，tab再+号和空格就是空心点</li></ul></li></ul><p>也可以<code>-</code>或者<code>*</code></p><h2 id="8-内外部跳转"><a href="#8-内外部跳转" class="headerlink" title="8. 内外部跳转"></a>8. 内外部跳转</h2><p> 快捷键：<code>ctrl+k</code></p><h3 id="1-外部跳转–超链接"><a href="#1-外部跳转–超链接" class="headerlink" title="1. 外部跳转–超链接"></a>1. 外部跳转–超链接</h3><p>格式：<code>[xxx]()</code>  </p><p><a href="www.baidu.com">百度</a></p><h3 id="2-内部跳转"><a href="#2-内部跳转" class="headerlink" title="2. 内部跳转"></a>2. 内部跳转</h3><p>格式：<code>[xxx](#要去的目的地--标题）</code></p><p><a href="#3.插入表格">我要去插入表格那里</a></p><h3 id="3-自动链接"><a href="#3-自动链接" class="headerlink" title="3. 自动链接"></a>3. 自动链接</h3><p>使用 <code>&lt;&gt;</code> 包括的 URL 或邮箱地址会被自动转换为超链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;https:&#x2F;&#x2F;www.baidu.com&gt;</span><br><span class="line"></span><br><span class="line">&lt;123@email.com&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></p><p><a href="mailto:&#49;&#x32;&#51;&#x40;&#101;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;">&#49;&#x32;&#51;&#x40;&#101;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;</a></p><h2 id="9-快捷键汇总"><a href="#9-快捷键汇总" class="headerlink" title="9. 快捷键汇总"></a>9. 快捷键汇总</h2><p><code>Ctrl 0</code> 到 ：普通文本、一级～六级标题；<code>Ctrl+1~6</code></p><p><code>Ctrl B</code>：加粗</p><p><code>Ctrl I</code>：斜体</p><p><code>Ctrl U</code>：下划线</p><p><code>Shift Alt 5</code>：删除线</p><p><code>Shift+Ctrl+Tab键上面那个键</code>：行内代码块</p><p><code>Ctrl K</code>：超链接</p><p><code>Ctrl T</code>：表格</p><p><code>Ctrl Shift Q</code>：引用</p><p><code>Shift Ctrl I</code>：图片</p><p><code>Shift Ctrl M</code>：公式块</p><h2 id="10-流程图"><a href="#10-流程图" class="headerlink" title="10. 流程图"></a>10. 流程图</h2><h2 id="11-序列图"><a href="#11-序列图" class="headerlink" title="11. 序列图"></a>11. 序列图</h2><h2 id="12-饼图"><a href="#12-饼图" class="headerlink" title="12. 饼图"></a>12. 饼图</h2><h2 id="13-甘特图"><a href="#13-甘特图" class="headerlink" title="13. 甘特图"></a>13. 甘特图</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107/"/>
      <url>/posts/16107/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网站颜色</title>
      <link href="/posts/62435/"/>
      <url>/posts/62435/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>我一直觉得只要两个人是相爱且已知相爱的，不管活着还是死了，不管能不能在一起都不虐。可后来我觉得，要是让我独自超越衰老地永远活着，爱你，守你，为你挡剑，看着你度过与我完全无关的人生，怎么能不伤心呢。——『遇龙』后有感</p><p align="right">——《轮回之境》网易云音乐热评</p></blockquote>    <div id="aplayer-yGaHVOLh" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="32957014" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><h2 id="RGB颜色值与十六进制颜色码转换工具"><a href="#RGB颜色值与十六进制颜色码转换工具" class="headerlink" title="RGB颜色值与十六进制颜色码转换工具"></a><a href="https://www.sioe.cn/yingyong/yanse-rgb-16/" target="_blank" rel="noopener">RGB颜色值与十六进制颜色码转换工具</a></h2><h2 id="十六进制颜色代码表，图表及调色板"><a href="#十六进制颜色代码表，图表及调色板" class="headerlink" title="十六进制颜色代码表，图表及调色板"></a><a href="https://encycolorpedia.cn/" target="_blank" rel="noopener">十六进制颜色代码表，图表及调色板</a></h2><h2 id="CSS3-渐变"><a href="#CSS3-渐变" class="headerlink" title="CSS3 渐变"></a>CSS3 渐变</h2><p>CSS3 渐变（gradients）可以让你在两个</p><p>或多个指定的颜色之间显示平稳的过渡。</p><p>以前，你必须使用图像来实现这些效果。但是，通过使用 CSS3 渐变（gradients），你可以减少下载的时间和宽带的使用。此外，渐变效果的元素在放大时看起来效果更好，因为渐变（gradient）是由浏览器生成的。</p><p>CSS3 定义了两种类型的渐变（gradients）：</p><ul><li><strong>线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向</strong></li><li><strong>径向渐变（Radial Gradients）- 由它们的中心定义</strong></li></ul><h2 id="linear-gradient-函数"><a href="#linear-gradient-函数" class="headerlink" title="linear-gradient()函数"></a>linear-gradient()函数</h2><p>linear-gradient() 函数用于创建一个<code>线性渐变</code>的 “图像”。</p><p>为了创建一个线性渐变，你需要设置一个起始点和一个方向（指定为一个角度）的渐变效果。你还要定义终止色。终止色就是你想让Gecko去平滑的过渡，并且你必须指定至少两种，当然也会可以指定更多的颜色去创建更复杂的渐变效果。</p><blockquote><p>CSS语法：background-image: linear-gradient(direction, color-stop1, color-stop2, …);</p></blockquote><ul><li>以下实例演示了从<code>头部开始</code>的线性渐变，从红色开始，转为黄色，再到蓝色:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#grad &#123;</span></span><br><span class="line">  <span class="attr">background-image:</span> <span class="string">linear-gradient(red,</span> <span class="string">yellow,</span> <span class="string">green);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>效果图：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://www.runoob.com/wp-content/uploads/2017/01/gradient_linear.png" alt="img"></p><ul><li>以下实例演示了从<code>左侧开始</code>的线性渐变，从红色开始，转为黄色:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#grad &#123;</span></span><br><span class="line">  <span class="attr">background-image:</span> <span class="string">linear-gradient(to</span> <span class="string">right,</span> <span class="string">red</span> <span class="string">,</span> <span class="string">yellow);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>以下实例演示了从<code>左上角到右下角</code>的线性渐变:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#grad &#123;</span></span><br><span class="line">  <span class="attr">background-image:</span> <span class="string">linear-gradient(to</span> <span class="string">bottom</span> <span class="string">right,</span> <span class="string">red</span> <span class="string">,</span> <span class="string">yellow);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>以下实例演示了线性渐变<code>指定一个角度</code>:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#grad &#123;</span></span><br><span class="line">  <span class="attr">background-image:</span> <span class="string">linear-gradient(180deg,</span> <span class="string">red,</span> <span class="string">yellow);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>以下实例演示了<code>多个终止色</code>:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#grad &#123;</span></span><br><span class="line">  <span class="attr">background-image:</span> <span class="string">linear-gradient(to</span> <span class="string">right,</span> <span class="string">red,orange,yellow,green,blue,indigo,violet);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>以下实例使用了<code>透明度</code>:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#grad &#123;</span></span><br><span class="line">  <span class="attr">background-image:</span> <span class="string">linear-gradient(to</span> <span class="string">right,</span> <span class="string">rgba(255,0,0,0),</span> <span class="string">rgba(255,0,0,1));</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github的静态博客搭建</title>
      <link href="/posts/40288/"/>
      <url>/posts/40288/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>钢琴+鼓点，敲代码绝配</p></blockquote>    <div id="aplayer-MBDFrxGO" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="857896" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><blockquote><p><strong>在换主题的时候出现了些问题所以把图床也删了，所以这篇文章图片丢失了，不过没啥关系，就是篇水文，但作为搭建后写的第一篇博文，还是不删了吧</strong></p></blockquote><h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h2><p>对于Windows需要到Git<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">官网</a>上下载，根据系统自行选择32-bit/64-bit。安装目录可以自主更改，没有影响。安装后右击鼠标看到<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/jankin6/imgs/imges2/image-20200419191256352.jpg" alt="">就说明安装成功了。</p><h2 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h2><p>到Node.js<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">官网</a>选择对应环境下载安装，安装完毕后，打开命令行（可以用系统自带的cmd，也可右击鼠标选择”Git Bash Here”，更推荐后者）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>可以看到<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/jankin6/imgs/imges2/image-20200420092744332.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>可以看到<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/jankin6/imgs/imges2/image-20200419192303615.png" alt="">（-v的意思是查看版本，显示的信息就是你已经安装的版本）</p><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><p>以上步骤都完成后，就可以安装hexo了，你可以先创建一个文件夹blog（文件名自定义，位置自定义），然后<code>cd</code>到这个文件夹下（或者直接在这个文件夹下右键git bush 打开）</p><p>输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>依旧用<code>hexo -v</code>查看一下版本</p><p>至此必要组件就已完成安装了。</p><p>接下来初始化hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure><p>其中myblog可以自定义，这行命令的意思就是新建一个名为myblog的文件夹并初始化。</p><p>接着</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> myblog //进入这个myblog文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>完成后，myblog文件夹目录下有：</p><ul><li><p>node_modules: 依赖包</p></li><li><p>public：存放生成的页面</p></li><li><p>scaffolds：生成文章的一些模板</p></li><li><p>source：用来存放你的文章</p></li><li><p>themes：主题</p></li><li><p>_config.yml: 博客的配置文件</p><p>…</p><p>打开命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server <span class="comment">#可以简化为hexo s</span></span><br></pre></td></tr></table></figure><p>当看到<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/jankin6/imgs/imges2/image-20200419194049593.png" alt="">时就说明博客生成成功了，打开浏览器输入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 就可以看到你生成的博客了，应该是这样的<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/jankin6/imgs/imges2/image-20200419194330411.png" alt=""></p></li></ul><p>返回git bush 窗口键入<code>ctrl+c</code>可以把服务关掉。</p><h2 id="4-GitHub创建个人仓库"><a href="#4-GitHub创建个人仓库" class="headerlink" title="4.GitHub创建个人仓库"></a>4.GitHub创建个人仓库</h2><p>首先，你先要有个Github账户，没有去注册一个吧。</p><p>进入GitHub首页，点击右上角的+号<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/jankin6/imgs/imges2/image-20200419194754049.png" alt="">选择<code>New repository</code>,然后填写仓库名称<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/jankin6/imgs/imges2/image-20200419194920749.png" alt=""></p><p>注意：仓库名称格式必须是<code>yourname.github.io</code>其中yourname为你注册Github的用户名)。</p><p>点击<code>create repository</code></p><h2 id="5-生成SSH添加到GitHub"><a href="#5-生成SSH添加到GitHub" class="headerlink" title="5.生成SSH添加到GitHub"></a>5.生成SSH添加到GitHub</h2><p>回到你的git bash中，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"yourname"</span></span><br><span class="line">git config --global user.email <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>这里的<code>yourname</code>输入你的GitHub用户名，<code>youremail</code>输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。</p><p>可以用以下两条，检查一下你有没有输对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>然后创建SSH,一路回车</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>这个时候它会告诉你已经生成了.ssh的文件夹。然后在<code>C:/Users/[username]</code>目录下找到名为<code>.ssh</code>的文件夹， 文件夹内会有两个文件，一个<code>id_rsa.pub</code>一个<code>id_rsa</code>，用文本编辑器打开<code>id_rsa.pub</code>，复制里面的的内容。</p><p>而后在GitHub的<code>setting</code>中，找到<code>SSH keys</code>的设置选项，点击<code>New SSH key</code><br>把你的<code>id_rsa.pub</code>里面的信息复制进去。如图<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/jankin6/imgs/imges2/image-20200419195618834.png" alt=""></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/jankin6/imgs/imges2/image-20200419195714510.png" alt=""></p><p>在gitbash中，查看是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>点击回车，然后会出现一个询问内容，输入<code>yes</code>，回车，会出现一段内容，<code>Hi &lt;account name&gt;! You&#39;ve successfully authenticated, but GitHub doesnot provide shell access.</code>。 说明连接成功。此处这个<code>&lt;account name&gt;</code>应该是你Github的用户名。</p><h2 id="6-将hexo部署到GitHub"><a href="#6-将hexo部署到GitHub" class="headerlink" title="6.将hexo部署到GitHub"></a>6.将hexo部署到GitHub</h2><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 <code>_config.yml</code>，翻到最后，修改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/YourgithubName/YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>YourgithubName就是你的GitHub账户</p><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>其中 <code>hexo clean</code>清除了你之前生成的东西，也可以不加。<br><code>hexo generate</code> 顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写<br><code>hexo deploy</code> 部署文章，可以用<code>hexo d</code>缩写</p><p>（# 也可以直接输入此命令<code>hexo g -d</code>，直接完成hexo g和hexo d的任务）</p><p>注意deploy时可能要你输入<code>username</code>和<code>password</code>。也就是你的Github账户和密码,</p><p>过一会儿就可以在<code>http://yourname.github.io</code> 这个网站看到你的博客了！！</p><h2 id="7-设置个人域名"><a href="#7-设置个人域名" class="headerlink" title="7.设置个人域名"></a>7.设置个人域名</h2><h2 id="8-发布文章"><a href="#8-发布文章" class="headerlink" title="8.发布文章"></a>8.发布文章</h2>]]></content>
      
      
      <categories>
          
          <category> Hexo搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
